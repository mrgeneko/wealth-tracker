<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wealth Tracker Dashboard</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.5/awesomplete.min.css">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.5/awesomplete.min.js"></script>
    <script src="scheduler.js"></script>
    <script src="statistics-filter.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #121212;
            color: #e0e0e0;
        }

        h1,
        h2 {
            color: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Grid Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: #1e1e1e;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        th,
        td {
            padding: 4px 8px;
            border: 1px solid #333;
            text-align: right;
            color: #e0e0e0;
        }

        th {
            background-color: #2d2d2d;
            font-weight: bold;
            text-align: center;
            color: #ffffff;
        }

        td:first-child,
        th:first-child {
            text-align: left;
        }

        /* Buttons */
        .btn {
            padding: 8px 12px;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn-primary {
            background-color: #0d6efd;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0b5ed7;
        }

        .btn-danger {
            background-color: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background-color: #bb2d3b;
        }

        /* Section Headers */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            margin-bottom: 10px;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .modal-content {
            background-color: #2d2d2d;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #444;
            width: 600px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: white;
        }

        .form-group {
            margin-bottom: 15px;
        }

        /* Prev-close small info icon (tooltip) */
        .prev-close-info {
            font-size: 0.75em;
            margin-left: 6px;
            color: #bbb;
            cursor: help;
            vertical-align: middle;
        }

        /* Custom instant tooltip */
        .custom-tooltip {
            position: absolute;
            background: #222;
            color: #fff;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            pointer-events: none;
            opacity: 0;
            transition: opacity .08s ease;
            z-index: 2000;
            white-space: pre-wrap;
            max-width: 360px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .custom-tooltip.visible { opacity: 1; }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #e0e0e0;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #333;
            color: #fff;
        }

        /* Awesomplete Autocomplete Styles (Dark Theme) */
        .awesomplete>ul {
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-height: 350px;
            overflow-y: auto;
        }

        .awesomplete>ul>li {
            color: #e0e0e0;
            padding: 10px 12px;
            border-bottom: 1px solid #444;
        }

        .awesomplete>ul>li:last-child {
            border-bottom: none;
        }

        .awesomplete>ul>li:hover {
            background: #3d3d3d;
            color: #fff;
        }

        .awesomplete>ul>li[aria-selected="true"] {
            background: #0d6efd;
            color: #fff;
        }

        .awesomplete>ul>li[aria-selected="true"] .ticker-exchange {
            background: rgba(255, 255, 255, 0.3);
        }

        .awesomplete mark {
            background: #0d6efd;
            color: #fff;
        }

        /* Ticker item styling */
        .ticker-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .ticker-main {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ticker-symbol {
            font-weight: bold;
            font-size: 1.1em;
        }

        .ticker-exchange {
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .ticker-exchange.nasdaq {
            background: #0d6efd;
            color: #fff;
        }

        .ticker-exchange.nyse {
            background: #198754;
            color: #fff;
        }

        .ticker-exchange.nyse-mkt {
            background: #20c997;
            color: #000;
        }

        .ticker-exchange.nyse-arca {
            background: #6f42c1;
            color: #fff;
        }

        .ticker-exchange.bats {
            background: #fd7e14;
            color: #000;
        }

        .ticker-exchange.iex {
            background: #6610f2;
            color: #fff;
        }

        .ticker-exchange.other {
            background: #6c757d;
            color: #fff;
        }

        .ticker-exchange.treasury {
            background: #dc3545;
            color: #fff;
        }

        .ticker-name {
            font-size: 0.85em;
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 350px;
        }

        /* Clickable Cells */
        .clickable-cell {
            cursor: pointer;
            color: #6ea8fe;
            text-decoration: none;
            display: block;
            width: 100%;
            height: 100%;
        }

        .clickable-cell:hover {
            text-decoration: underline;
            background-color: #2c3e50;
        }

        .edit-icon {
            font-size: 0.8em;
            margin-left: 5px;
            color: #888;
            visibility: hidden;
        }

        .clickable-cell:hover .edit-icon {
            visibility: visible;
        }

        .row-total {
            font-weight: bold;
            background-color: #252525;
        }

        .total-row td {
            font-weight: bold;
            background-color: #333;
            border-top: 2px solid #555;
        }

        .positive {
            color: #4caf50;
        }

        .negative {
            color: #f44336;
        }

        /* Tabs */
        .tab {
            overflow: hidden;
            border-bottom: 1px solid #444;
            margin-bottom: 20px;
        }

        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            font-size: 17px;
            color: #aaa;
        }

        .tab button:hover {
            background-color: #333;
            color: white;
        }

        .tab button.active {
            background-color: #2d2d2d;
            color: white;
            border-bottom: 2px solid #0d6efd;
        }

        .tab-content {
            display: none;
            animation: fadeEffect 1s;
        }

        @keyframes fadeEffect {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Sortable Headers */
        .sortable-header {
            cursor: pointer;
            user-select: none;
        }

        .sortable-header:hover {
            background-color: #3d3d3d;
        }

        .sort-indicator {
            margin-left: 5px;
            font-size: 0.8em;
            color: #888;
        }

        .sort-indicator.active {
            color: #0d6efd;
        }

        /* Normalize header font-size so sortable labels match other headers */
        #investment-grid th, .sortable-header {
            font-size: 0.95em;
            line-height: 1.1;
        }

        /* Reduce padding for compact columns */
        #investment-grid th.col-prevclose, #investment-grid td[id^="prevClose-"] {
            padding: 2px 6px;
        }
        #investment-grid th.col-source, #investment-grid td[id^="source-"] {
            padding: 2px 6px;
        }
        #investment-grid th.col-valuechg, #investment-grid td[id^="valueChange-"] {
            padding: 2px 6px;
        }

        /* Log Table Overrides */
        #log-table th:first-child,
        #log-table td:first-child {
            position: static !important;
            background-color: transparent !important;
            z-index: auto !important;
        }

        /* Icon Button */
        .icon-btn {
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            margin-left: 10px;
            color: #0d6efd;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 36px;
            width: 36px;
            border-radius: 50%;
            transition: background-color 0.3s;
        }

        .icon-btn:hover {
            background-color: rgba(13, 110, 253, 0.1);
        }

        .plus-icon {
            font-weight: bold;
            line-height: 1;
            display: inline-block;
            transition: transform 0.3s;
        }

        .icon-btn:hover .plus-icon {
            transform: scale(1.2);
        }

        /* Settings Button */
        .settings-btn {
            position: absolute;
            top: 0;
            right: 0;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: #0d6efd;
            font-size: 1.5em;
            border-radius: 50%;
            transition: background-color 0.3s, transform 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }

        .settings-btn:hover {
            background-color: rgba(13, 110, 253, 0.1);
            transform: scale(1.1);
        }

        .gear-icon {
            font-size: 1.2em;
            line-height: 1;
        }

        /* Settings Modal Styles */
        .settings-content {
            max-height: 60vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 12px;
        }

        .settings-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }

        /* Statistics table inside settings - reset global table styles */
        #metadataStats table {
            background: transparent;
            box-shadow: none;
            margin-bottom: 0;
        }

        #metadataStats td {
            border: none;
            padding: 4px 0;
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .settings-section h3 {
            margin: 0 0 15px 0;
            color: #ffffff;
            font-size: 1.1em;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 0;
        }

        .setting-item label {
            flex: 1;
            color: #e0e0e0;
            font-weight: normal;
        }

        .setting-item input[type="checkbox"] {
            margin-left: 10px;
        }

        .setting-item select {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 6px 8px;
            min-width: 120px;
        }

        /* Settings Dropdown */
        .settings-dropdown {
            display: none;
            position: absolute;
            top: 50px;
            right: 0;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 120px;
            overflow: hidden;
        }

        .dropdown-item {
            padding: 12px 16px;
            color: #e0e0e0;
            cursor: pointer;
            transition: background-color 0.3s;
            border-bottom: 1px solid #444;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background-color: #3d3d3d;
            color: #ffffff;
        }
    </style>
</head>

<body>
    <div class="container">
        <div style="position: relative;">
            <h1>Wealth Tracker Dashboard</h1>
            <div id="no-assets-warning" style="display:none; color: #ffb74d; margin-top: 8px;">No accounts data
                available ‚Äî check server/API connection.</div>
            <button id="settingsBtn" class="settings-btn" title="Menu" onclick="toggleSettingsDropdown()">
                <span class="gear-icon">‚öôÔ∏è</span>
            </button>
            <div id="settingsDropdown" class="settings-dropdown">
                <div class="dropdown-item" onclick="showLogs()">Logs</div>
                <div class="dropdown-item" onclick="openSettingsModal()">Settings</div>
            </div>
        </div>
        <div id="last-updated" style="color: #aaa; font-size: 0.9em; margin-bottom: 20px;"></div>

        <div class="tab">
            <button class="tablinks active" onclick="openTab(event, 'Accounts')">Accounts</button>
            <button class="tablinks" onclick="openTab(event, 'Historical')">Historical Values</button>
            <button class="tablinks" onclick="openTab(event, 'Projections')">Projections</button>
            <button class="tablinks" onclick="openTab(event, 'Watchlists')">Watchlists</button>
        </div>

        <div id="Accounts" class="tab-content" style="display: block;">
            <!-- Investment Accounts -->
            <div class="section-header">
                <h2 style="display: flex; align-items: center; gap: 10px;">
                    <span>Investment Accounts</span>
                    <button class="icon-btn" title="Add Account" onclick="openAccountModal('investment')"
                        style="font-size: inherit; white-space: nowrap; margin-left: 32px;">
                        <span class="plus-icon" style="font-size: inherit; white-space: nowrap;">+ Account</span>
                    </button>
                    <span style="color: white; margin: 0 16px;">&nbsp;|&nbsp;</span>
                    <button class="icon-btn" title="Add Ticker" onclick="openAddSymbolModal()"
                        style="font-size: inherit; white-space: nowrap;">
                        <span class="plus-icon" style="font-size: inherit; white-space: nowrap;">+ Ticker</span>
                    </button>
                    <span style="color: white; margin: 0 16px;">&nbsp;|&nbsp;</span>
                    <button class="icon-btn" title="Expand Accounts" onclick="toggleAccountsCollapse()"
                        style="font-size: inherit; white-space: nowrap; margin-left: 32px;">
                        <span id="collapse-toggle" class="plus-icon"
                            style="font-size: inherit; white-space: nowrap;">Expand Accounts</span>
                    </button>
                </h2>
            </div>
            <table id="investment-grid">
                <thead></thead>
                <tbody></tbody>
            </table>

            <!-- Bank Accounts -->
            <div class="section-header">
                <h2 style="display: flex; align-items: center; gap: 10px;">
                    <span>Bank Accounts</span>
                    <button class="icon-btn" title="Add Account" onclick="openAccountModal('bank')">
                        <span class="plus-icon">+</span>
                    </button>
                </h2>
            </div>
            <table id="bank-grid">
                <thead></thead>
                <tbody></tbody>
            </table>

            <!-- Fixed Assets -->
            <div class="section-header">
                <h2 style="display: flex; align-items: center; gap: 10px;">
                    <span>Fixed Assets</span>
                    <button class="icon-btn" title="Add Asset" onclick="openAssetModal()">
                        <span class="plus-icon">+</span>
                    </button>
                </h2>
            </div>
            <table id="asset-grid">
                <thead></thead>
                <tbody></tbody>
            </table>

            <div id="total-net-worth"
                style="font-size: 1.5em; font-weight: bold; margin-top: 30px; margin-bottom: 20px;"></div>
        </div>

        <div id="Historical" class="tab-content">
            <h2>Historical Values</h2>
            <p>Historical data visualization coming soon.</p>
        </div>

        <div id="Projections" class="tab-content">
            <h2>Projections</h2>
            <p>Future wealth projections coming soon.</p>
        </div>

        <div id="Watchlists" class="tab-content">
            <div class="section-header">
                <h2>Watchlist Management</h2>
                <button class="btn btn-primary" onclick="refreshWatchlistUI()">Refresh</button>
            </div>

            <div id="watchlistStatus" style="margin-bottom: 12px; color: #aaa; font-size: 0.9em;"></div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                <div style="background: #1e1e1e; border: 1px solid #333; border-radius: 8px; padding: 12px;">
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label for="watchlistProvider">Provider</label>
                        <select id="watchlistProvider" onchange="onWatchlistProviderChanged()"></select>
                    </div>
                    <div id="watchlistProviderCaps" style="color: #cfcfcf; font-size: 0.9em; line-height: 1.5;"></div>
                </div>

                <div style="background: #1e1e1e; border: 1px solid #333; border-radius: 8px; padding: 12px;">
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label for="watchlistTab">Watchlist Tab</label>
                        <select id="watchlistTab"></select>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn" style="background-color: #555; color: white;"
                            onclick="switchWatchlistTab()">Switch Tab</button>
                        <button class="btn" style="background-color: #555; color: white;"
                            onclick="loadWatchlistTickers()">Load Tickers</button>
                    </div>
                </div>
            </div>

            <div
                style="background: #1e1e1e; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                <h3 style="margin-top: 0;">Add Ticker</h3>
                <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 12px; align-items: end;">
                    <div class="form-group" style="margin: 0;">
                        <label for="watchlistAddTicker">Ticker</label>
                        <input id="watchlistAddTicker" type="text" placeholder="e.g., AAPL" />
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label for="watchlistAddAssetType">Asset Type</label>
                        <select id="watchlistAddAssetType"></select>
                    </div>
                    <button class="btn btn-primary" onclick="addWatchlistTicker()">Add</button>
                </div>
            </div>

            <div class="section-header" style="margin-top: 0;">
                <h3 style="margin: 0;">Tickers</h3>
                <div style="color: #aaa; font-size: 0.9em;" id="watchlistTickersMeta"></div>
            </div>
            <table>
                <thead>
                    <tr>
                        <th style="text-align:left;">Ticker</th>
                        <th style="text-align:center;">Action</th>
                    </tr>
                </thead>
                <tbody id="watchlistTickersBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="width: 350px;">
            <h2 id="confirmModalTitle">Confirm</h2>
            <p id="confirmModalMessage" style="margin-bottom: 20px;"></p>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button type="button" class="btn" style="background-color: #555; color: white;"
                    onclick="closeModal('confirmModal')">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmModalOk">Delete</button>
            </div>
        </div>
    </div>

    <!-- Account Modal -->
    <div id="accountModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('accountModal')">&times;</span>
            <h2 id="accountModalTitle">Add Account</h2>
            <form id="accountForm">
                <input type="hidden" id="accId">
                <input type="hidden" id="accCategory">
                <div class="form-group">
                    <label for="accName">Account Name</label>
                    <input type="text" id="accName" required>
                </div>
                <div class="form-group">
                    <label for="accType">Type</label>
                    <input type="text" id="accType" placeholder="e.g., 401k, Roth IRA, Checking">
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn btn-danger" id="btnDeleteAccount" style="display:none;"
                        onclick="deleteAccount()">Delete</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Position Modal -->
    <div id="positionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('positionModal')">&times;</span>
            <h2 id="positionModalTitle">Edit Position</h2>
            <form id="positionForm">
                <input type="hidden" id="posId">
                <input type="hidden" id="posAccountId">
                <input type="hidden" id="posSymbol">
                <div class="form-group" id="posSymbolGroup">
                    <label for="posSymbol">Symbol</label>
                    <div id="posSymbolDisplay"
                        style="padding: 8px; border: 1px solid #555; border-radius: 4px; background-color: #555; color: #fff; width: 100%;">
                    </div>
                </div>
                <div class="form-group">
                    <div id="posAccountGroup">
                        <label for="posAccount">Account</label>
                        <div id="posAccountDisplay"
                            style="padding: 8px; border: 1px solid #555; border-radius: 4px; background-color: #555; color: #fff; width: 100%;">
                        </div>
                    </div>
                    <label for="posQuantity">Quantity</label>
                    <input type="number" step="any" id="posQuantity" required>
                    <small style="color: #aaa;">For Cash, enter the total value.</small>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn btn-danger" id="btnDeletePosition" style="display:none;"
                        onclick="deletePosition()">Delete</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Asset Modal -->
    <div id="assetModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('assetModal')">&times;</span>
            <h2 id="assetModalTitle">Add Asset</h2>
            <form id="assetForm">
                <input type="hidden" id="assetId">
                <div class="form-group">
                    <label for="assetName">Name</label>
                    <input type="text" id="assetName" required>
                </div>
                <div class="form-group">
                    <label for="assetType">Type</label>
                    <select id="assetType">
                        <option value="real_estate">Real Estate</option>
                        <option value="vehicle">Vehicle</option>
                        <option value="other">Other</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="assetValue">Value</label>
                    <input type="number" step="any" id="assetValue" required>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn btn-danger" id="btnDeleteAsset" style="display:none;"
                        onclick="deleteAsset()">Delete</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('settingsModal')">&times;</span>
            <h2>Settings</h2>
            <div class="settings-content">
                <div class="settings-section">
                    <h3>Dashboard Preferences</h3>
                    <div class="setting-item">
                        <label for="autoRefresh">Auto refresh account and positions</label>
                        <input type="checkbox" id="autoRefresh" checked>
                    </div>
                    <div class="setting-item">
                        <label for="refreshInterval">Refresh interval (seconds)</label>
                        <select id="refreshInterval">
                            <option value="30">30 seconds</option>
                            <option value="60" selected>1 minute</option>
                            <option value="300">5 minutes</option>
                            <option value="600">10 minutes</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="theme">Theme</label>
                        <select id="theme">
                            <option value="dark" selected>Dark</option>
                            <option value="light">Light</option>
                        </select>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>Symbol Registry Management</h3>
                    <p style="font-size: 0.9em; color: #aaa; margin-bottom: 10px;">Manage metadata population and
                        refresh cycles</p>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px;">
                        <button class="btn btn-primary" id="btnRefreshMetadata" onclick="refreshMetadata()"
                            style="text-align: left;">
                            üîÑ Refresh Yahoo Metadata
                        </button>
                        <button class="btn btn-primary" id="btnCleanupExpired" onclick="cleanupExpired()"
                            style="text-align: left;">
                            üóëÔ∏è Cleanup Expired Securities
                        </button>
                    </div>

                    <!-- Metadata Statistics -->
                    <div id="metadataStats"
                        style="background: #2a2a2a; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                        <p style="margin: 0 0 8px 0; font-size: 0.9em; color: #aaa;">Statistics (auto-updating)</p>
                        <div style="font-size: 0.85em;">
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">Total</span>
                                <span id="stat-total" style="color: #fff; font-weight: bold;">0</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">With Data</span>
                                <span id="stat-with" style="color: #fff; font-weight: bold;">0</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">Without Data</span>
                                <span id="stat-without" style="color: #fff; font-weight: bold;">0</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0; font-weight: bold;">Complete %</span>
                                <span style="color: #fff; font-weight: bold;"><span
                                        id="stat-completion">0</span>%</span>
                            </div>
                            <!-- Queue Metrics -->
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444; border-top: 1px solid #555; margin-top: 8px; padding-top: 8px;">
                                <span style="color: #ffb74d;">Queue Size</span>
                                <span id="stat-queue-size" style="color: #fff; font-weight: bold;">0</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #ffb74d;">Est. Time</span>
                                <span id="stat-queue-time" style="color: #fff; font-weight: bold;">0 min</span>
                            </div>
                            <!-- Processing Metrics -->
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444; border-top: 1px solid #555; margin-top: 8px; padding-top: 8px;">
                                <span style="color: #81c784;">Recent Updates</span>
                                <span id="stat-recent-updates" style="color: #fff; font-weight: bold;">0</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;">
                                <span style="color: #81c784;">Avg Time/Symbol</span>
                                <span id="stat-avg-time" style="color: #fff; font-weight: bold;">0s</span>
                            </div>
                        </div>
                    </div>
                    <p id="metadataStatus" style="font-size: 0.85em; color: #aaa; margin-top: 8px;"></p>

                    <!-- Per-Type Statistics Filtering (Phase 8.3) -->
                    <div style="background: #3a3a3a; padding: 10px; border-radius: 4px; margin-top: 10px;">
                        <p style="margin: 0 0 8px 0; font-size: 0.9em; color: #aaa; font-weight: bold;">Filter by Type
                        </p>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px;"
                            id="typeFilterButtons"></div>
                        <div id="typeStats" style="font-size: 0.85em; display: none;">
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-top: 1px solid #555; border-bottom: 1px solid #444; color: #e0e0e0;">
                                <span id="typeStatsLabel">Type: </span>
                                <span style="color: #aaa;"></span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">Total</span>
                                <span id="typeStat-total" style="color: #fff; font-weight: bold;">0</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">With Data</span>
                                <span id="typeStat-with" style="color: #fff; font-weight: bold;">0</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">Without Data</span>
                                <span id="typeStat-without" style="color: #fff; font-weight: bold;">0</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">Complete %</span>
                                <span style="color: #fff; font-weight: bold;"><span
                                        id="typeStat-completion">0</span>%</span>
                            </div>
                            <div style="display: flex; gap: 5px; margin-top: 8px;">
                                <button class="btn btn-primary" id="btnRefreshType"
                                    style="flex: 1; padding: 6px; font-size: 0.8em;" onclick="refreshSelectedType()">üîÑ
                                    Refresh</button>
                                <button class="btn btn-danger" id="btnResetType"
                                    style="flex: 1; padding: 6px; font-size: 0.8em;" onclick="resetSelectedType()">‚ö†Ô∏è
                                    Reset</button>
                                <button class="btn" id="btnClearType"
                                    style="flex: 1; padding: 6px; font-size: 0.8em; background-color: #555; color: white;"
                                    onclick="clearTypeFilter()">‚úï Clear</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>Scheduled Metadata Refresh</h3>
                    <p style="font-size: 0.9em; color: #aaa; margin-bottom: 10px;">Automatically refresh metadata at
                        specified intervals</p>
                    <div class="setting-item">
                        <label for="refreshSchedule">Refresh Schedule</label>
                        <select id="refreshSchedule">
                            <option value="3600000">Every Hour</option>
                            <option value="10800000">Every 3 Hours</option>
                            <option value="21600000">Every 6 Hours</option>
                            <option value="43200000">Every 12 Hours</option>
                            <option value="86400000">Every 24 Hours</option>
                            <option value="null" selected>Never</option>
                        </select>
                    </div>
                    <div id="scheduleStatus"
                        style="background: #2a2a2a; padding: 10px; border-radius: 4px; margin-top: 10px; font-size: 0.85em;">
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; color: #aaa;">
                            <span>Status</span>
                            <span id="schedule-status" style="color: #e0e0e0;">Disabled</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; color: #aaa;">
                            <span>Next Refresh</span>
                            <span id="schedule-next" style="color: #e0e0e0;">‚Äî</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 4px 0; color: #aaa;">
                            <span>Last Refresh</span>
                            <span id="schedule-last" style="color: #e0e0e0;">‚Äî</span>
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>System Health & Performance</h3>
                    <p style="font-size: 0.9em; color: #aaa; margin-bottom: 10px;">Monitor sync status and system
                        performance metrics</p>

                    <!-- File Refresh Status -->
                    <div id="fileRefreshStatus"
                        style="background: #2a2a2a; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                        <p style="margin: 0 0 8px 0; font-size: 0.9em; color: #aaa; font-weight: bold;">üìÅ File Sync
                            Status</p>
                        <div id="fileStatusList" style="font-size: 0.85em;">
                            <div style="color: #888; text-align: center; padding: 10px;">Loading...</div>
                        </div>
                    </div>

                    <!-- Performance Metrics -->
                    <div id="performanceMetrics"
                        style="background: #2a2a2a; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                        <p style="margin: 0 0 8px 0; font-size: 0.9em; color: #aaa; font-weight: bold;">üìä Performance
                            Metrics</p>
                        <div style="font-size: 0.85em;">
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">Overall Health</span>
                                <span id="metric-health" style="font-weight: bold;">‚Äî</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">Success Rate</span>
                                <span id="metric-success-rate" style="color: #fff; font-weight: bold;">‚Äî</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">Total Symbols</span>
                                <span id="metric-total-symbols" style="color: #fff; font-weight: bold;">‚Äî</span>
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #444;">
                                <span style="color: #e0e0e0;">Recent Errors</span>
                                <span id="metric-recent-errors" style="color: #fff; font-weight: bold;">‚Äî</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;">
                                <span style="color: #e0e0e0;">Last Updated</span>
                                <span id="metric-last-updated" style="color: #888; font-size: 1.4em;">‚Äî</span>
                            </div>
                        </div>
                    </div>

                    <button class="btn btn-primary" onclick="loadPerformanceMetrics()" style="width: 100%;">
                        üîÑ Refresh Metrics
                    </button>
                </div>

                <div class="settings-section">
                    <h3>System</h3>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn btn-primary" onclick="exportData()">Export Data</button>
                        <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">Import
                            Data</button>
                        <input type="file" id="importFile" accept=".json" style="display: none;"
                            onchange="importData(this)">
                    </div>
                    <button class="btn btn-danger" onclick="clearCache()">Clear Cache</button>
                </div>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
                <button type="button" class="btn" style="background-color: #555; color: white;"
                    onclick="closeModal('settingsModal')">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Logs Modal -->
    <div id="logsModal" class="modal">
        <div class="modal-content logs-modal-content">
            <span class="close" onclick="closeModal('logsModal')">&times;</span>
            <h2>System Logs</h2>
            <div id="logs-container" style="display: flex; height: 600px; border: 1px solid #444;">
                <div id="log-list-pane"
                    style="width: 27.5%; min-width: 150px; overflow-y: auto; overflow-x: auto; background: #1e1e1e;">
                    <table id="log-table" style="width: 100%; font-size: 0.8em; table-layout: fixed;">
                        <thead>
                            <tr>
                                <th id="col-file" style="text-align: left; padding: 5px; position: relative;">File</th>
                                <th id="col-time"
                                    style="text-align: left; padding: 5px; width: 132px; white-space: nowrap;">Time</th>
                                <th id="col-size"
                                    style="text-align: right; padding: 5px; width: 70px; white-space: nowrap;">Size</th>
                            </tr>
                        </thead>
                        <tbody id="log-list"></tbody>
                    </table>
                </div>
                <div id="pane-resizer"
                    style="width: 5px; cursor: col-resize; background-color: #444; user-select: none; z-index: 10;">
                </div>
                <div id="log-viewer-pane"
                    style="flex: 1; min-width: 150px; overflow-y: auto; padding: 10px; background: #121212; font-family: monospace; white-space: pre-wrap;">
                    Select a log file to view...
                </div>
            </div>
        </div>
    </div>

    <!-- Add Ticker Modal -->
    <div id="addSymbolModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addSymbolModal')">&times;</span>
            <h2>Add Ticker</h2>
            <form id="addSymbolForm">
                <div class="form-group">
                    <label for="newSymbol">Ticker</label>
                    <div style="display: flex; gap: 5px;">
                        <input type="text" id="newSymbol" required maxlength="50"
                            style="text-transform:uppercase; flex: 1;" class="awesomplete" autocomplete="off"
                            onchange="lookupSymbolMetadata()">
                        <button type="button" class="btn btn-primary" id="btnLookupSymbol"
                            onclick="lookupSymbolMetadata()" style="padding: 8px 12px;">üîç</button>
                    </div>
                    <p id="symbolLookupStatus" style="font-size: 0.85em; color: #aaa; margin-top: 5px; display: none;">
                    </p>
                </div>

                <!-- Symbol Metadata Display (Phase 7) -->
                <div id="symbolMetadataDisplay"
                    style="background: #2a2a2a; padding: 10px; border-radius: 4px; margin-bottom: 15px; display: none;">
                    <p style="margin: 0 0 8px 0; font-size: 0.9em; color: #888;">Symbol Information</p>
                    <table style="width: 100%; font-size: 0.85em;">
                        <tbody>
                            <tr style="border-bottom: 1px solid #444;">
                                <td style="padding: 4px 0; color: #aaa;">Name:</td>
                                <td style="text-align: right; padding: 4px 0;"><span id="symbolMetadataName">‚Äî</span>
                                </td>
                            </tr>
                            <tr style="border-bottom: 1px solid #444;">
                                <td style="padding: 4px 0; color: #aaa;">Type:</td>
                                <td style="text-align: right; padding: 4px 0;"><span id="symbolMetadataType">‚Äî</span>
                                </td>
                            </tr>
                            <tr style="border-bottom: 1px solid #444;">
                                <td style="padding: 4px 0; color: #aaa;">Exchange:</td>
                                <td style="text-align: right; padding: 4px 0;"><span
                                        id="symbolMetadataExchange">‚Äî</span></td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 0; color: #aaa;">Verified:</td>
                                <td style="text-align: right; padding: 4px 0;"><span
                                        id="symbolMetadataVerified">‚úì</span></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <input type="hidden" id="newSymbolType">
                <div class="form-group">
                    <label for="newSymbolAccount">Account</label>
                    <select id="newSymbolAccount" required></select>
                </div>
                <div class="form-group">
                    <label for="newSymbolQuantity">Quantity</label>
                    <input type="number" id="newSymbolQuantity" min="0" step="any" value="0" required>
                </div>
                <div id="addSymbolError" style="color: #f44336; margin-bottom: 10px; display: none;"></div>
                <div style="display: flex; justify-content: flex-end; gap: 10px;">
                    <button type="button" class="btn" style="background-color: #555; color: white;"
                        onclick="closeModal('addSymbolModal')">Cancel</button>
                    <button type="submit" class="btn btn-primary">Add</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Ticker autocomplete setup
        let symbolAutocomplete = null;
        let autocompleteTimeout = null;

        function openAddSymbolModal() {
            document.getElementById('addSymbolError').style.display = 'none';
            document.getElementById('addSymbolForm').reset();
            // Populate account dropdown
            const accountSelect = document.getElementById('newSymbolAccount');
            accountSelect.innerHTML = '';
            if (lastAssetsData && lastAssetsData.accounts) {
                const investmentAccounts = lastAssetsData.accounts.filter(a => a.category === 'investment' || !a.category);
                investmentAccounts.forEach(acc => {
                    const opt = document.createElement('option');
                    opt.value = acc.id;
                    opt.textContent = acc.name + (acc.type ? ` (${acc.type})` : '');
                    accountSelect.appendChild(opt);
                });
            }

            // Initialize Awesomplete
            const input = document.getElementById('newSymbol');
            // Store metadata by symbol to bypass Awesomplete's data stripping
            let metadataStore = {};

            if (!symbolAutocomplete) {
                symbolAutocomplete = new Awesomplete(input, {
                    minChars: 1,
                    maxItems: 15,
                    autoFirst: true,
                    filter: () => true, // We filter on server
                    sort: false, // We sort on server
                    data: function (item) {
                        return { label: item.value, value: item.value };
                    },
                    item: function (item) {
                        // Retrieve full metadata from our side-channel store
                        const meta = metadataStore[item.value] || {};
                        const name = meta.name || 'Unknown Name';
                        const exchange = meta.exchange || 'Unknown';
                        const exchangeClass = (exchange || '').toLowerCase().replace(/\s+/g, '-');

                        const li = document.createElement('li');
                        li.innerHTML = `
                                    <div class="ticker-item">
                                        <div class="ticker-main">
                                            <span class="ticker-symbol">${item.value}</span>
                                            <span class="ticker-exchange ${exchangeClass}">${exchange}</span>
                                        </div>
                                        <div class="ticker-name">${name}</div>
                                    </div>
                                `;
                        return li;
                    }
                });

                // Dynamic fetch listener
                input.addEventListener('input', function () {
                    const query = this.value;
                    if (query.length < 1) return;

                    if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
                    autocompleteTimeout = setTimeout(async () => {
                        try {
                            const res = await fetch(`/api/autocomplete/search?q=${encodeURIComponent(query)}`);
                            const data = await res.json();

                            // Update the side-channel store
                            data.results.forEach(t => {
                                metadataStore[t.ticker] = t;
                            });

                            const list = data.results.map(t => ({
                                label: t.ticker,
                                value: t.ticker
                            }));

                            symbolAutocomplete.list = list;
                        } catch (err) {
                            console.error('Autocomplete error:', err);
                        }
                    }, 300); // 300ms debounce
                });
            }

            document.getElementById('addSymbolModal').style.display = 'block';
        }

        document.getElementById('addSymbolForm').onsubmit = async function (e) {
            e.preventDefault();
            const symbol = document.getElementById('newSymbol').value.trim().toUpperCase();
            const type = document.getElementById('newSymbolType').value;
            const accountId = document.getElementById('newSymbolAccount').value;
            const quantity = parseFloat(document.getElementById('newSymbolQuantity').value);
            if (!symbol || !accountId || isNaN(quantity)) return;
            // Check if symbol already exists in this account
            let symbolExists = false;
            if (lastAssetsData && lastAssetsData.accounts) {
                const acc = lastAssetsData.accounts.find(a => String(a.id) === String(accountId));
                if (acc) {
                    acc.holdings.stocks.forEach(pos => { if ((pos.ticker || '').toUpperCase() === symbol) symbolExists = true; });
                    acc.holdings.bonds.forEach(pos => { if ((pos.ticker || '').toUpperCase() === symbol) symbolExists = true; });
                }
            }
            if (symbolExists) {
                document.getElementById('addSymbolError').innerText = 'Symbol already exists in this account.';
                document.getElementById('addSymbolError').style.display = 'block';
                return;
            }
            // Add symbol to selected account with specified quantity
            try {
                let currency = 'USD';
                if (lastAssetsData && lastAssetsData.accounts) {
                    const acc = lastAssetsData.accounts.find(a => String(a.id) === String(accountId));
                    if (acc && acc.currency) currency = acc.currency;
                }
                // Fetch current price and publish to Kafka for persistence
                // Pass type so bonds route to Webull instead of Yahoo
                try {
                    await fetch('/api/fetch-price', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ticker: symbol, type })
                    });
                } catch (e) {
                    console.warn('Price fetch failed:', e);
                }
                // Prefetch metadata for the new ticker
                try {
                    await fetch('/api/metadata/prefetch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ticker: symbol })
                    });
                } catch (e) {
                    console.warn('Metadata prefetch failed:', e);
                }

                const response = await fetch('/api/positions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        account_id: accountId,
                        ticker: symbol,
                        type,
                        quantity,
                        currency
                    })
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Failed to add position');
                }
                closeModal('addSymbolModal');
                fetchAssets();
            } catch (err) {
                console.error('Error adding symbol:', err);
                document.getElementById('addSymbolError').innerText = err.message || 'Error adding symbol.';
                document.getElementById('addSymbolError').style.display = 'block';
            }
        };
        const socket = io();
        let currentPrices = {};
        let lastAssetsData = null;
        let previousPrices = {}; // Store previous prices for comparison
        let previousValues = {}; // Store previous values for comparison

        // --- Sorting State ---
        let investmentGridSort = { column: 'symbol', direction: 'asc' };
        let accountOrder = [];

        // --- Accounts Collapse State ---
        let accountsCollapsed = true; // Start with accounts collapsed by default

        // --- Socket.IO Listeners ---
        socket.on('price_update', (data) => {
            console.log('Price update received');
            const oldPrices = { ...currentPrices };
            currentPrices = data;

            if (lastAssetsData) {
                // Use in-place update for smoother animations
                updateInvestmentGridInPlace('investment-grid', lastAssetsData.accounts.filter(a => a.category === 'investment' || !a.category), oldPrices);
            }
        });

        socket.on('assets_update', (data) => {
            console.log('Assets update received');
            fetchAssets();
        });

        // --- Data Fetching ---
        async function fetchAssets() {
            console.log('Fetching assets...');
            try {
                const response = await fetch('/api/assets');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('Assets received:', data);
                lastAssetsData = data;
                renderAll();
                const warn = document.getElementById('no-assets-warning');
                if (warn) warn.style.display = 'none';
            } catch (error) {
                console.error('Error fetching assets:', error);
                const warn = document.getElementById('no-assets-warning');
                if (warn) warn.style.display = 'block';
            }
        }

        // --- Rendering ---
        function renderAll() {
            if (!lastAssetsData) return;

            // Filter accounts
            let investmentAccounts = lastAssetsData.accounts.filter(a => a.category === 'investment' || !a.category);

            // Initialize or update accountOrder
            if (accountOrder.length === 0) {
                accountOrder = investmentAccounts.map(a => a.id);
            } else {
                const currentIds = new Set(investmentAccounts.map(a => a.id));
                accountOrder = accountOrder.filter(id => currentIds.has(id));
                investmentAccounts.forEach(a => {
                    if (!accountOrder.includes(a.id)) accountOrder.push(a.id);
                });
            }

            // Sort investmentAccounts based on accountOrder
            investmentAccounts.sort((a, b) => {
                const idxA = accountOrder.findIndex(id => String(id) === String(a.id));
                const idxB = accountOrder.findIndex(id => String(id) === String(b.id));
                return idxA - idxB;
            });

            const bankAccounts = lastAssetsData.accounts.filter(a => a.category === 'bank');

            // Combine fixed assets
            const fixedAssets = [
                ...(lastAssetsData.real_estate || []).map(a => ({ ...a, type: 'real_estate' })),
                ...(lastAssetsData.vehicles || []).map(a => ({ ...a, type: 'vehicle' }))
            ];

            renderInvestmentGridWithFlashes('investment-grid', investmentAccounts, {});
            renderBankGrid('bank-grid', bankAccounts);
            renderAssetGrid('asset-grid', fixedAssets);

            // Calculate Net Worth
            let netWorth = 0;
            // Add fixed assets
            fixedAssets.forEach(a => netWorth += a.value);
            // Add accounts (calculated in render functions, but we can re-calc here or grab from DOM)
            // Let's re-calc for accuracy
            lastAssetsData.accounts.forEach(acc => {
                if (acc.holdings.cash) netWorth += acc.holdings.cash.value;
                acc.holdings.stocks.forEach(p => {
                    const price = getPriceDataForSymbol(p.ticker)?.price || 0;
                    netWorth += p.quantity * price;
                });
                acc.holdings.bonds.forEach(p => {
                    const price = getPriceDataForSymbol(p.ticker)?.price || 0;
                    // Bonds use price/100
                    netWorth += p.quantity * (price / 100.0);
                });
            });

            document.getElementById('total-net-worth').innerText = `Total Net Worth: $${formatNumber(netWorth)}`;
            document.getElementById('last-updated').innerText = `Last Updated: ${new Date().toLocaleString()}`;
        }

        // In-place update function for smooth animations
        function updateInvestmentGridInPlace(tableId, accounts, oldPrices) {
            if (!accounts || accounts.length === 0) return;

            // Collect all unique symbols
            const allSymbols = new Set();
            accounts.forEach(acc => {
                acc.holdings.stocks.forEach(pos => allSymbols.add(pos.ticker));
                acc.holdings.bonds.forEach(pos => allSymbols.add(pos.ticker));
            });

            let grandTotalValueChange = 0;

            allSymbols.forEach(sym => {
                const normalized = normalizeTicker(sym);
                const oldPriceData = oldPrices[sym] || oldPrices[normalized];
                const newPriceData = getPriceDataForSymbol(sym);

                if (!newPriceData) return;

                let price = newPriceData.price;
                // Prefer a valid previous_close_price from the incoming data.
                // RATIONALE: Some scrapers (or intermittent updates) may not provide
                // `previous_close_price` on every update, or might send an empty
                // string / zero. If we blindly set prev-close to that, the dashboard
                // will display 0 and compute changes from an incorrect base.
                // To protect the UI value we:
                // 1) Accept an incoming previous_close_price only if it's a valid
                //    positive number (parseFloat > 0).
                // 2) If the incoming value is missing/invalid, fall back to the
                //    previously-known value (from oldPriceData) if available.
                // This mirrors the server-side cache behavior and prevents noisy
                // scrapers from erasing a valid Prev Close.
                let prevClose = 0;
                if (newPriceData.previous_close_price !== undefined && newPriceData.previous_close_price !== null && newPriceData.previous_close_price !== '') {
                    const parsedPrev = parseFloat(newPriceData.previous_close_price);
                    if (!isNaN(parsedPrev) && parsedPrev > 0) {
                        prevClose = parsedPrev;
                    } else if (oldPriceData && oldPriceData.previous_close_price) {
                        // incoming prev close is present but invalid (e.g. 0 or NaN) ‚Äî fall back to old
                        prevClose = parseFloat(oldPriceData.previous_close_price) || 0;
                    }
                } else if (oldPriceData && oldPriceData.previous_close_price) {
                    // incoming prev close missing ‚Äî reuse the old value
                    prevClose = parseFloat(oldPriceData.previous_close_price) || 0;
                }
                let changeVal = price - prevClose;
                let changePct = prevClose ? ((price - prevClose) / prevClose * 100).toFixed(3) + '%' : '0%';
                // timeStr will hold display time (HH:MM:SS); timeDatePart holds MM/DD for tooltip
                let timeStr = '-';
                let timeDatePart = '';
                let sourceStr = newPriceData.source || '-';

                if (newPriceData.time) {
                    const d = new Date(newPriceData.time);
                    if (!isNaN(d.getTime())) {
                        // Build display time (HH:mm:ss) and date part (M/D) for tooltip
                        const month = d.getMonth() + 1;
                        const day = d.getDate();
                        const hours = d.getHours().toString().padStart(2, '0');
                        const minutes = d.getMinutes().toString().padStart(2, '0');
                        const seconds = d.getSeconds().toString().padStart(2, '0');
                        timeDatePart = `${month}/${day}`;
                        timeStr = `${hours}:${minutes}:${seconds}`;
                    } else {
                        timeStr = newPriceData.time;
                        timeDatePart = '';
                    }
                } else if (oldPriceData && oldPriceData.time) {
                    // Fallback to previously-known time if current update lacks it
                    const d = new Date(oldPriceData.time);
                    if (!isNaN(d.getTime())) {
                        const month = d.getMonth() + 1;
                        const day = d.getDate();
                        const hours = d.getHours().toString().padStart(2, '0');
                        const minutes = d.getMinutes().toString().padStart(2, '0');
                        const seconds = d.getSeconds().toString().padStart(2, '0');
                        timeDatePart = `${month}/${day}`;
                        timeStr = `${hours}:${minutes}:${seconds}`;
                    }
                }

                let color = '#e0e0e0';
                if (changeVal > 0) color = '#4caf50';
                if (changeVal < 0) color = '#f44336';

                let changePctNum = 0;
                if (changePct && changePct !== '0%') {
                    changePctNum = parseFloat(changePct.replace('%', '').replace(',', '')) || 0;
                }

                // Calculate totals for this symbol
                let symTotalValue = 0;
                let symTotalValueChange = 0;

                accounts.forEach(acc => {
                    let pos = acc.holdings.stocks.find(p => p.ticker === sym);
                    let isBond = false;
                    if (!pos) {
                        pos = acc.holdings.bonds.find(p => p.ticker === sym);
                        if (pos) isBond = true;
                    }

                    if (pos) {
                        let calcPrice = price;
                        let calcChange = changeVal;
                        if (isBond) {
                            calcPrice = price / 100.0;
                            calcChange = changeVal / 100.0;
                        }

                        const value = pos.quantity * calcPrice;
                        symTotalValue += value;
                        symTotalValueChange += pos.quantity * calcChange;

                        // Update account cell in-place
                        const cellId = `cell-${sym}-${acc.id}`;
                        const cell = document.getElementById(cellId);
                        if (cell) {
                            const oldValue = previousValues[cellId] || 0;
                            if (oldValue !== 0 && value !== oldValue) {
                                applyFlash(cell, value > oldValue);
                            }
                            previousValues[cellId] = value;
                            // Update cell content
                            const clickableSpan = cell.querySelector('.clickable-cell');
                            if (clickableSpan) {
                                clickableSpan.innerHTML = `${formatNumber(value)}<br><small>${pos.quantity.toFixed(0)}</small>`;
                            }
                        }
                    }
                });

                grandTotalValueChange += symTotalValueChange;

                // Update price cell
                const priceCell = document.getElementById(`price-${sym}`);
                if (priceCell) {
                    if (oldPriceData && oldPriceData.price !== 0 && price !== oldPriceData.price) {
                        applyFlash(priceCell, price > oldPriceData.price);
                    }
                    priceCell.textContent = formatNumber(price);
                }

                // Update prevClose cell
                const prevCloseCell = document.getElementById(`prevClose-${sym}`);
                if (prevCloseCell) {
                    // Only update the cell if the incoming data contains a valid prev close.
                    if (newPriceData.previous_close_price !== undefined && newPriceData.previous_close_price !== null && newPriceData.previous_close_price !== '') {
                        const parsedPrev = parseFloat(newPriceData.previous_close_price);
                        if (!isNaN(parsedPrev) && parsedPrev > 0) {
                            // Build tooltip from metadata if available
                            const sourceMeta = newPriceData.prev_close_source || newPriceData.previous_close_source || newPriceData.source || (oldPriceData && oldPriceData.prev_close_source) || '';
                            const timeMeta = newPriceData.prev_close_time || newPriceData.previous_close_time || newPriceData.capture_time || (oldPriceData && oldPriceData.prev_close_time) || '';
                            let tooltip = '';
                            if (sourceMeta) tooltip += `Source: ${sourceMeta}`;
                            if (timeMeta) tooltip += (tooltip ? '\n' : '') + `Time: ${timeMeta}`;
                            // Set the cell text and attach the tooltip text to dataset (no separate 'i' icon)
                            prevCloseCell.textContent = formatNumber(parsedPrev);
                            if (tooltip) prevCloseCell.dataset.tooltip = tooltip;
                            else delete prevCloseCell.dataset.tooltip;
                        } else {
                            // incoming invalid value: do not overwrite existing cell
                        }
                    } else {
                        // incoming value is missing: do not overwrite existing cell
                        if (oldPriceData && oldPriceData.previous_close_price) {
                            console.warn(`[PrevClose] Skipping update for ${sym}, incoming prev close missing ‚Äî preserving previous value ${oldPriceData.previous_close_price}`);
                        }
                    }
                }

                // Update change cell
                const changeCell = document.getElementById(`change-${sym}`);
                if (changeCell) {
                    if (oldPriceData && oldPriceData.change !== undefined && changeVal !== oldPriceData.change) {
                        applyFlash(changeCell, changeVal > oldPriceData.change);
                    }
                    changeCell.textContent = formatNumber(changeVal);
                    changeCell.style.color = color;
                }

                // Update change% cell
                const changePctCell = document.getElementById(`changePct-${sym}`);
                if (changePctCell) {
                    if (oldPriceData) {
                        const oldChangePctNum = parseFloat((oldPriceData.change_percent || '0%').replace('%', '').replace(',', '')) || 0;
                        if (oldChangePctNum !== 0 && changePctNum !== oldChangePctNum) {
                            applyFlash(changePctCell, changePctNum > oldChangePctNum);
                        }
                    }
                    changePctCell.textContent = `${changePctNum.toFixed(3)}%`;
                    changePctCell.style.color = color;
                }

                // Update time cell (text flash)
                const timeCell = document.getElementById(`time-${sym}`);
                if (timeCell) {
                    if (oldPriceData && oldPriceData.time !== newPriceData.time) {
                        applyTextFlash(timeCell);
                    }
                    timeCell.textContent = timeStr;
                    if (timeDatePart) timeCell.dataset.tooltip = timeDatePart;
                    else delete timeCell.dataset.tooltip;
                }

                // Update source cell (text flash)
                const sourceCell = document.getElementById(`source-${sym}`);
                if (sourceCell) {
                    if (oldPriceData && oldPriceData.source !== newPriceData.source) {
                        applyTextFlash(sourceCell);
                    }
                    sourceCell.textContent = sourceStr;
                }

                // Update value change cell
                const valueChangeCell = document.getElementById(`valueChange-${sym}`);
                if (valueChangeCell) {
                    const oldValueChange = previousValues[`valueChange-${sym}`] || 0;
                    if (oldValueChange !== 0 && symTotalValueChange !== oldValueChange) {
                        applyFlash(valueChangeCell, symTotalValueChange > oldValueChange);
                    }
                    previousValues[`valueChange-${sym}`] = symTotalValueChange;
                    valueChangeCell.textContent = formatNumber(symTotalValueChange);
                    valueChangeCell.style.color = color;
                }

                // Update total cell
                const totalCell = document.getElementById(`total-${sym}`);
                if (totalCell) {
                    const oldTotal = previousValues[`total-${sym}`] || 0;
                    if (oldTotal !== 0 && symTotalValue !== oldTotal) {
                        applyFlash(totalCell, symTotalValue > oldTotal);
                    }
                    previousValues[`total-${sym}`] = symTotalValue;
                    totalCell.textContent = formatNumber(symTotalValue, 0);
                }
            });

            // Calculate grand total for all accounts and update account totals
            let grandTotal = 0;
            accounts.forEach(acc => {
                let accTotal = 0;
                if (acc.holdings.cash) accTotal += acc.holdings.cash.value;
                acc.holdings.stocks.forEach(p => {
                    const priceData = getPriceDataForSymbol(p.ticker);
                    let price = priceData?.price || 0;
                    accTotal += p.quantity * price;
                });
                acc.holdings.bonds.forEach(p => {
                    const priceData = getPriceDataForSymbol(p.ticker);
                    let price = priceData?.price || 0;
                    // Bonds use price/100
                    accTotal += p.quantity * (price / 100.0);
                });
                grandTotal += accTotal;

                // Update account total cell in Total row
                const accTotalCell = document.getElementById(`total-row-acc-${acc.id}`);
                if (accTotalCell) {
                    accTotalCell.textContent = formatNumber(accTotal);
                }
            });

            // Update Total row Value Change cell
            const totalRowValueChangeCell = document.getElementById('total-row-value-change');
            if (totalRowValueChangeCell) {
                let totalChangeColor = '#e0e0e0';
                if (grandTotalValueChange > 0) totalChangeColor = '#4caf50';
                if (grandTotalValueChange < 0) totalChangeColor = '#f44336';
                totalRowValueChangeCell.textContent = formatNumber(grandTotalValueChange);
                totalRowValueChangeCell.style.color = totalChangeColor;
            }

            // Update Total row Grand Total cell
            const totalRowGrandTotalCell = document.getElementById('total-row-grand-total');
            if (totalRowGrandTotalCell) {
                totalRowGrandTotalCell.textContent = formatNumber(grandTotal, 0);
            }

            // Update Total Net Worth (includes fixed assets and bank accounts)
            let netWorth = grandTotal;
            // Add fixed assets
            if (lastAssetsData) {
                (lastAssetsData.real_estate || []).forEach(a => netWorth += a.value);
                (lastAssetsData.vehicles || []).forEach(a => netWorth += a.value);
                // Add bank accounts
                lastAssetsData.accounts.filter(a => a.category === 'bank').forEach(acc => {
                    if (acc.holdings.cash) netWorth += acc.holdings.cash.value;
                });
            }
            document.getElementById('total-net-worth').innerText = `Total Net Worth: $${formatNumber(netWorth)}`;

            // Update last updated timestamp
            document.getElementById('last-updated').innerText = `Last Updated: ${new Date().toLocaleString()}`;
        }

        // Helper function to apply background flash animation
        function applyFlash(element, isPositive) {
            element.classList.remove('flash-positive', 'flash-negative');
            // Force reflow to restart animation
            void element.offsetWidth;
            element.classList.add(isPositive ? 'flash-positive' : 'flash-negative');
        }

        // Helper function to apply text flash animation
        function applyTextFlash(element) {
            element.classList.remove('flash-text');
            // Force reflow to restart animation
            void element.offsetWidth;
            element.classList.add('flash-text');
        }

        function toggleAccountsCollapse() {
            accountsCollapsed = !accountsCollapsed;
            const toggleButton = document.getElementById('collapse-toggle');
            if (accountsCollapsed) {
                toggleButton.innerHTML = 'Expand Accounts';
                toggleButton.title = 'Expand Accounts';
            } else {
                toggleButton.innerHTML = 'Collapse Accounts';
                toggleButton.title = 'Collapse Accounts';
            }
            // Re-render the investment grid with the new collapsed state
            if (lastAssetsData) {
                const investmentAccounts = lastAssetsData.accounts.filter(a => a.category === 'investment' || !a.category);
                renderInvestmentGridWithFlashes('investment-grid', investmentAccounts, {});
            }
        }

        function renderInvestmentGrid(tableId, accounts) {
            renderInvestmentGridWithFlashes(tableId, accounts, {});
        }

        function renderInvestmentGridWithFlashes(tableId, accounts, oldPrices) {
            const gridTable = document.getElementById(tableId);
            const thead = gridTable.querySelector('thead');
            const tbody = gridTable.querySelector('tbody');

            if (!accounts || accounts.length === 0) {
                thead.innerHTML = '';
                tbody.innerHTML = '<tr><td>No accounts found. Add one to get started.</td></tr>';
                return;
            }

            // Collect all unique symbols
            // Type-driven only: do not special-case the literal ticker "CASH" here.
            // (Cash is determined by position.type === 'cash' on the backend.)
            const allSymbols = new Set();
            accounts.forEach(acc => {
                acc.holdings.stocks.forEach(pos => allSymbols.add(pos.ticker));
                acc.holdings.bonds.forEach(pos => allSymbols.add(pos.ticker));
            });
            const sortedSymbols = Array.from(allSymbols).sort();

            // Header with sortable columns
            const sortIndicator = (col) => {
                if (investmentGridSort.column === col) {
                    return `<span class="sort-indicator active">${investmentGridSort.direction === 'asc' ? '‚ñ≤' : '‚ñº'}</span>`;
                }
                return '<span class="sort-indicator">‚áÖ</span>';
            };
            let headerHtml = `<tr><th class="sortable-header" style="text-align: left" onclick="sortInvestmentGrid('symbol')">Ticker${sortIndicator('symbol')}</th>`;


            if (accountsCollapsed) {
                // When collapsed, show only a "Shares" column
                headerHtml += `<th style="text-align: center">Shares</th>`;
            } else {
                // When expanded, show all account columns
                accounts.forEach(acc => {
                    const accJson = escapeHtml(JSON.stringify(acc));
                    const accType = acc.type ? acc.type.toUpperCase() : '';
                    headerHtml += `<th style="text-align: center" draggable="true" ondragstart="dragStart(event, '${acc.id}')" ondragover="allowDrop(event)" ondrop="drop(event, '${acc.id}')"><span class="clickable-cell" onclick="openAccountModal(null, ${accJson})">${acc.name}<br><span class='account-type'>${accType}</span> <span class="edit-icon">‚úé</span></span></th>`;
                });
            }

            headerHtml += `<th class="col-prevclose">Prev Close</th><th>Price</th><th>P/E</th><th>Yield</th><th>Chg</th><th class="sortable-header" onclick="sortInvestmentGrid('changePct')">Chg %${sortIndicator('changePct')}</th><th>Time</th><th class="col-source">Source</th><th class="sortable-header col-valuechg" onclick="sortInvestmentGrid('valueChange')">Value Chg${sortIndicator('valueChange')}</th><th class="sortable-header" onclick="sortInvestmentGrid('total')">Total${sortIndicator('total')}</th></tr>`;
            thead.innerHTML = headerHtml;

            let bodyHtml = '';
            let grandTotalValueChange = 0;

            // Build row data for sorting
            const rowData = [];
            sortedSymbols.forEach(sym => {
                let rowInfo = { symbol: sym, changePct: 0, valueChange: 0, total: 0, name: '', sector: '' };
                let price = 0;
                let changePct = '0%';
                let changeVal = 0;
                let prevClose = 0;
                let timeStr = '-';
                let timeDatePart = '';
                let sourceStr = '-';
                let color = '#e0e0e0';

                const normalized = normalizeTicker(sym);
                const newPriceData = getPriceDataForSymbol(sym);
                const oldPricesLookup = oldPrices[sym] || oldPrices[normalized];
                if (newPriceData) {
                    price = newPriceData.price;
                    // Prefer a valid previous_close_price from the currentPrices object.
                    // NOTE: When the dashboard performs a full render (e.g. page refresh)
                    // or is fed a fresh snapshot of `currentPrices`, some scrapers may
                    // still provide no previous_close_price for certain tickers. To
                    // maintain a consistent UX and avoid computing changes from a
                    // bogus zero base, we only accept incoming prev-close values
                    // that are valid positive numbers. When a current snapshot lacks
                    // a valid previous_close_price, we fall back to the previously
                    // known value (from oldPrices) ‚Äî this mirrors server-side cache
                    // behavior and prevents accidental erasure of a valid Prev Close.
                    prevClose = 0;
                    if (newPriceData.previous_close_price !== undefined && newPriceData.previous_close_price !== null && newPriceData.previous_close_price !== '') {
                        const parsedPrev = parseFloat(newPriceData.previous_close_price);
                        if (!isNaN(parsedPrev) && parsedPrev > 0) {
                            prevClose = parsedPrev;
                        } else if (oldPricesLookup && oldPricesLookup.previous_close_price) {
                            // fallback to prev value if current data doesn't provide valid prev close
                            prevClose = parseFloat(oldPrices[sym].previous_close_price) || 0;
                            console.warn(`[PrevClose] Current data for ${sym} missing valid prev close ‚Äî falling back to previous value ${prevClose}`);
                        }
                    } else if (oldPricesLookup && oldPricesLookup.previous_close_price) {
                        // Fall back to previously known value when current has none
                        prevClose = parseFloat(oldPrices[sym].previous_close_price) || 0;
                    }
                    changeVal = price - prevClose;
                    changePct = prevClose ? ((price - prevClose) / prevClose * 100).toFixed(3) + '%' : '0%';
                    console.log(`[PrevClose] ${sym}: price=${price}, prevClose=${prevClose}, changeVal=${changeVal}, changePct=${changePct}`);

                    // Prefer to display only HH:MM:SS and store MM/DD for tooltip
                    timeDatePart = '';
                    if (newPriceData.time) {
                        const d = new Date(newPriceData.time);
                        if (!isNaN(d.getTime())) {
                            const month = d.getMonth() + 1;
                            const day = d.getDate();
                            const hours = d.getHours().toString().padStart(2, '0');
                            const minutes = d.getMinutes().toString().padStart(2, '0');
                            const seconds = d.getSeconds().toString().padStart(2, '0');
                            timeDatePart = `${month}/${day}`;
                            timeStr = `${hours}:${minutes}:${seconds}`;
                        } else {
                            timeStr = newPriceData.time;
                            timeDatePart = '';
                        }
                    } else if (oldPricesLookup && oldPricesLookup.time) {
                        const d = new Date(oldPricesLookup.time);
                        if (!isNaN(d.getTime())) {
                            const month = d.getMonth() + 1;
                            const day = d.getDate();
                            const hours = d.getHours().toString().padStart(2, '0');
                            const minutes = d.getMinutes().toString().padStart(2, '0');
                            const seconds = d.getSeconds().toString().padStart(2, '0');
                            timeDatePart = `${month}/${day}`;
                            timeStr = `${hours}:${minutes}:${seconds}`;
                        }
                    }

                    sourceStr = newPriceData.source || '-';
                    if (changeVal > 0) color = '#4caf50';
                    if (changeVal < 0) color = '#f44336';
                }

                // Metadata placeholders
                let metaName = '';
                let metaSector = '';
                let metaPE = '-';
                let metaYield = '-';

                // Find metadata from position (if any account has valid metadata)
                for (const acc of accounts) {
                    const stockPos = acc.holdings.stocks.find(p => p.ticker === sym);
                    if (stockPos) {
                        if (stockPos.short_name) metaName = stockPos.short_name;
                        if (stockPos.sector) metaSector = stockPos.sector;
                        // Prefer real-time calculations when we have TTM data and a current price
                        const priceNow = (typeof price === 'number' && isFinite(price)) ? price : null;
                        if (stockPos.ttm_eps && priceNow && Number(stockPos.ttm_eps) !== 0) {
                            try {
                                const v = priceNow / Number(stockPos.ttm_eps);
                                if (isFinite(v) && v > 0 && v < 10000) metaPE = v.toFixed(2);
                            } catch (e) { }
                        } else if (stockPos.trailing_pe) metaPE = stockPos.trailing_pe.toFixed(2);

                        if (stockPos.ttm_dividend_amount && priceNow) {
                            try {
                                const yieldPct = (Number(stockPos.ttm_dividend_amount) / priceNow) * 100.0;
                                if (isFinite(yieldPct) && yieldPct >= 0 && yieldPct <= 100) {
                                    metaYield = yieldPct.toFixed(2) + '%';
                                }
                            } catch (e) { }
                        } else if (stockPos.dividend_yield) {
                            // Stored dividend_yield may be either a fraction (0.0123) or a
                            // percent-like value (1.23 or 123). Normalize for display:
                            // - If value looks like a percent (1..100) show as-is with %
                            // - Otherwise assume a fractional value and multiply by 100
                            const raw = parseFloat(stockPos.dividend_yield);
                            if (!isNaN(raw)) {
                                if (raw > 1 && raw <= 100) {
                                    metaYield = raw.toFixed(2) + '%';
                                } else if (raw > 100) {
                                    // absurdly large numbers are considered bad data
                                    metaYield = '-';
                                } else {
                                    metaYield = (raw * 100).toFixed(2) + '%';
                                }
                            }
                        }
                        if (metaName && metaSector) break; // Found enough info
                    }
                }

                // Store for sorting
                rowInfo.name = metaName;
                rowInfo.sector = metaSector;

                // Show the symbol and expose the full name as a hover tooltip on the Symbol cell
                // Show symbol and attach tooltip text to `data-tooltip` for custom tooltip handling
                let rowHtml = `<tr><td style="text-align: left; font-weight: bold; max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" data-tooltip="${escapeHtml(metaName)}">${sym}</td>`;


                let symTotalValue = 0;
                let symTotalValueChange = 0;
                let symTotalShares = 0;

                accounts.forEach(acc => {
                    // Find position in stocks or bonds
                    let pos = acc.holdings.stocks.find(p => p.ticker === sym);
                    let isBond = false;
                    if (!pos) {
                        pos = acc.holdings.bonds.find(p => p.ticker === sym);
                        if (pos) isBond = true;
                    }

                    if (pos) {
                        let calcPrice = price;
                        let calcChange = changeVal;
                        if (isBond) {
                            calcPrice = price / 100.0;
                            calcChange = changeVal / 100.0;
                        }

                        const value = pos.quantity * calcPrice;
                        symTotalValue += value;
                        symTotalValueChange += pos.quantity * calcChange;
                        symTotalShares += pos.quantity;
                        const posType = isBond ? 'bond' : 'stock';
                        const posData = { id: pos.id, account_id: acc.id, symbol: pos.ticker, type: posType, quantity: pos.quantity };
                        const posJson = escapeHtml(JSON.stringify(posData));

                        // Check for value changes and apply flash animations
                        const cellId = `cell-${sym}-${acc.id}`;
                        let flashClass = '';

                        // Check if this cell value has changed
                        const oldValue = previousValues[cellId] || 0;
                        const newValue = value;
                        if (oldValue !== 0 && newValue !== oldValue) {
                            flashClass = newValue > oldValue ? 'flash-positive' : 'flash-negative';
                        }
                        previousValues[cellId] = newValue;

                        if (!accountsCollapsed) {
                            rowHtml += `<td id="${cellId}" class="${flashClass}"><span class="clickable-cell" onclick="openPositionModal(${posJson})">${formatNumber(value)}<br><small>${pos.quantity.toFixed(0)}</small></span></td>`;
                        }
                    } else {
                        if (!accountsCollapsed) {
                            // Display type based on what's in holdings (visual only, backend determines actual type)
                            let posType = 'stock';
                            for (const account of accounts) {
                                if (account.holdings.bonds.find(b => b.ticker === sym)) {
                                    posType = 'bond';
                                    break;
                                }
                            }
                            const addPosData = { account_id: acc.id, account_name: acc.name, symbol: sym, quantity: 0 };
                            const addPosJson = escapeHtml(JSON.stringify(addPosData));
                            rowHtml += `<td><span class="clickable-cell" style="color: #555; text-align: center;" onclick="openPositionModal(${addPosJson})">+</span></td>`;
                        }
                    }
                });

                // If collapsed, add single Shares column
                if (accountsCollapsed) {
                    rowHtml += `<td style="text-align: center;">${symTotalShares.toFixed(0)}</td>`;
                }

                // Check for price changes and apply flash animations
                const priceCellId = `price-${sym}`;
                const oldPriceData = oldPricesLookup; // use either raw or normalized key
                let priceFlashClass = '';

                if (oldPriceData && newPriceData) {
                    const oldPrice = oldPriceData.price;
                    const newPrice = newPriceData.price;
                    if (oldPrice !== 0 && newPrice !== oldPrice) {
                        priceFlashClass = newPrice > oldPrice ? 'flash-positive' : 'flash-negative';
                    }
                }

                // Parse changePct to number for sorting
                let changePctNum = 0;
                if (changePct && changePct !== '0%') {
                    changePctNum = parseFloat(changePct.replace('%', '').replace(',', '')) || 0;
                }
                rowInfo.changePct = changePctNum;
                rowInfo.valueChange = symTotalValueChange;
                rowInfo.total = symTotalValue;

                // Build a tooltip showing prev-close source & time (if available)
                let prevCloseTooltip = '';
                if (prevClose && prevClose !== 0) {
                    const prevCloseSource = (newPriceData && (newPriceData.prev_close_source || newPriceData.previous_close_source)) || (oldPrices[sym] && (oldPrices[sym].prev_close_source || oldPrices[sym].previous_close_source)) || '';
                    const prevCloseTime = (newPriceData && (newPriceData.prev_close_time || newPriceData.previous_close_time || newPriceData.capture_time)) || (oldPrices[sym] && (oldPrices[sym].prev_close_time || oldPrices[sym].previous_close_time || oldPrices[sym].capture_time)) || '';
                    if (prevCloseSource) prevCloseTooltip += `Source: ${prevCloseSource}`;
                    if (prevCloseTime) prevCloseTooltip += (prevCloseTooltip ? '\n' : '') + `Time: ${prevCloseTime}`;
                }
                // Render Prev Close without the separate info icon; attach tooltip text to `data-tooltip` if available
                rowHtml += `<td id="prevClose-${sym}" ${prevCloseTooltip ? `data-tooltip="${escapeHtml(prevCloseTooltip)}"` : ''}>${formatNumber(prevClose)}</td>`;
                rowHtml += `<td id="${priceCellId}" class="${priceFlashClass}">${formatNumber(price)}</td>`;
                rowHtml += `<td>${metaPE}</td>`;
                rowHtml += `<td>${metaYield}</td>`;

                // Check for change and change% column changes
                const changeCellId = `change-${sym}`;
                const changePctCellId = `changePct-${sym}`;
                let changeFlashClass = '';
                let changePctFlashClass = '';

                if (oldPriceData && newPriceData) {
                    const oldChange = oldPriceData.change || 0;
                    const newChange = changeVal;
                    if (oldChange !== 0 && newChange !== oldChange) {
                        changeFlashClass = newChange > oldChange ? 'flash-positive' : 'flash-negative';
                    }

                    const oldChangePct = oldPriceData.change_percent || '0%';
                    const newChangePct = changePct;
                    if (oldChangePct !== '0%' && newChangePct !== oldChangePct) {
                        const oldChangePctNum = parseFloat(oldChangePct.replace('%', '').replace(',', '')) || 0;
                        const newChangePctNum = changePctNum;
                        if (oldChangePctNum !== 0 && newChangePctNum !== oldChangePctNum) {
                            changePctFlashClass = newChangePctNum > oldChangePctNum ? 'flash-positive' : 'flash-negative';
                        }
                    }
                }

                rowHtml += `<td id="${changeCellId}" class="${changeFlashClass}" style="color: ${color}">${formatNumber(changeVal)}</td>`;
                rowHtml += `<td id="${changePctCellId}" class="${changePctFlashClass}" style="color: ${color}">${changePctNum.toFixed(3)}%</td>`;

                // Check for time and source changes (text flash)
                const timeCellId = `time-${sym}`;
                const sourceCellId = `source-${sym}`;
                let timeFlashClass = '';
                let sourceFlashClass = '';

                if (oldPriceData && newPriceData) {
                    const oldTime = oldPriceData.time || '-';
                    const newTime = timeStr;
                    const oldSource = oldPriceData.source || '-';
                    const newSource = sourceStr;

                    if (oldTime !== newTime) {
                        timeFlashClass = 'flash-text';
                    }
                    if (oldSource !== newSource) {
                        sourceFlashClass = 'flash-text';
                    }
                }

                rowHtml += `<td id="${timeCellId}" class="${timeFlashClass}" style="font-size: 0.7em; color: #e0e0e0; font-weight: 600;" ${timeDatePart ? `data-tooltip="${escapeHtml(timeDatePart)}"` : ''}>${timeStr}</td>`;
                rowHtml += `<td id="${sourceCellId}" class="${sourceFlashClass}" style="font-size: 0.7em; color: #e0e0e0; font-weight: 600;">${sourceStr}</td>`;

                grandTotalValueChange += symTotalValueChange;

                // Check for value change and total changes
                const valueChangeCellId = `valueChange-${sym}`;
                const totalCellId = `total-${sym}`;
                let valueChangeFlashClass = '';
                let totalFlashClass = '';

                if (oldPriceData && newPriceData) {
                    const oldValueChange = previousValues[valueChangeCellId] || 0;
                    const newValueChange = symTotalValueChange;
                    if (oldValueChange !== 0 && newValueChange !== oldValueChange) {
                        valueChangeFlashClass = newValueChange > oldValueChange ? 'flash-positive' : 'flash-negative';
                    }
                    previousValues[valueChangeCellId] = newValueChange;

                    const oldTotal = previousValues[totalCellId] || 0;
                    const newTotal = symTotalValue;
                    if (oldTotal !== 0 && newTotal !== oldTotal) {
                        totalFlashClass = newTotal > oldTotal ? 'flash-positive' : 'flash-negative';
                    }
                    previousValues[totalCellId] = newTotal;
                }

                rowHtml += `<td id="${valueChangeCellId}" class="${valueChangeFlashClass}" style="color: ${color}">${formatNumber(symTotalValueChange)}</td>`;
                rowHtml += `<td id="${totalCellId}" class="${totalFlashClass} row-total">${formatNumber(symTotalValue, 0)}</td></tr>`;

                rowInfo.html = rowHtml;
                rowData.push(rowInfo);
            });

            // Sort rows based on current sort state
            rowData.sort((a, b) => {
                let aVal = a[investmentGridSort.column];
                let bVal = b[investmentGridSort.column];
                if (investmentGridSort.column === 'symbol' || investmentGridSort.column === 'name') {
                    aVal = (aVal || '').toLowerCase();
                    bVal = (bVal || '').toLowerCase();
                }
                if (aVal < bVal) return investmentGridSort.direction === 'asc' ? -1 : 1;
                if (aVal > bVal) return investmentGridSort.direction === 'asc' ? 1 : -1;
                return 0;
            });

            // Build body HTML from sorted rows
            rowData.forEach(row => {
                bodyHtml += row.html;
            });

            // Cash Row
            // IMPORTANT: This table starts with the Symbol column. Ensure CASH aligns with that column (Name removed).
            let cashRowHtml = '<tr><td style="text-align: left; font-weight: bold;">CASH</td>';
            let totalCash = 0;
            accounts.forEach(acc => {
                let cashVal = 0;
                let cashPos = acc.holdings.cash;
                if (cashPos) {
                    cashVal = cashPos.value;
                    if (!accountsCollapsed) {
                        const posData = { id: cashPos.id, account_id: acc.id, symbol: 'CASH', type: 'cash', quantity: cashVal };
                        const posJson = escapeHtml(JSON.stringify(posData));
                        cashRowHtml += `<td><span class="clickable-cell" onclick="openPositionModal(${posJson})">${formatNumber(cashVal)}</span></td>`;
                    }
                } else {
                    if (!accountsCollapsed) {
                        const posData = { account_id: acc.id, symbol: 'CASH', type: 'cash', quantity: 0 };
                        const posJson = escapeHtml(JSON.stringify(posData));
                        cashRowHtml += `<td><span class="clickable-cell" style="color: #555; text-align: center;" onclick="openPositionModal(${posJson})">+</span></td>`;
                    }
                }
                totalCash += cashVal;
            });
            // If collapsed, add single cell for Shares column (show dash for cash)
            if (accountsCollapsed) {
                cashRowHtml += '<td style="text-align: center;">-</td>';
            }
            // Placeholder cells for: Prev Close, Price, P/E, Yield, Chg, Chg %, Time, Source, Value Chg
            cashRowHtml += '<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td>';
            cashRowHtml += `<td class="row-total">${formatNumber(totalCash, 0)}</td></tr>`;
            bodyHtml += cashRowHtml;

            // Account Totals
            // IMPORTANT: Keep alignment with Symbol/Sector columns.
            // Symbol/Sector should be blank for TOTAL where applicable.
            let totalRowHtml = '<tr class="total-row"><td>TOTAL</td>';
            let grandTotal = 0;
            accounts.forEach(acc => {
                let accTotal = 0;
                if (acc.holdings.cash) accTotal += acc.holdings.cash.value;
                acc.holdings.stocks.forEach(p => {
                    const price = getPriceDataForSymbol(p.ticker)?.price || 0;
                    accTotal += p.quantity * price;
                });
                acc.holdings.bonds.forEach(p => {
                    const price = getPriceDataForSymbol(p.ticker)?.price || 0;
                    accTotal += p.quantity * (price / 100.0);
                });
                grandTotal += accTotal;
                if (!accountsCollapsed) {
                    totalRowHtml += `<td id="total-row-acc-${acc.id}">${formatNumber(accTotal)}</td>`;
                }
            });
            // If collapsed, add single cell for Shares column (show dash for totals)
            if (accountsCollapsed) {
                totalRowHtml += '<td style="text-align: center;">-</td>';
            }
            let totalChangeColor = '#e0e0e0';
            if (grandTotalValueChange > 0) totalChangeColor = '#4caf50';
            if (grandTotalValueChange < 0) totalChangeColor = '#f44336';

            // Placeholder cells for: Prev Close, Price, P/E, Yield, Chg, Chg %, Time, Source
            totalRowHtml += '<td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td>';
            totalRowHtml += `<td id="total-row-value-change" style="color: ${totalChangeColor}">${formatNumber(grandTotalValueChange)}</td>`;
            totalRowHtml += `<td id="total-row-grand-total">${formatNumber(grandTotal, 0)}</td></tr>`;
            bodyHtml += totalRowHtml;

            // Removed Add Position Buttons row

            tbody.innerHTML = bodyHtml;
        }

        function sortInvestmentGrid(column) {
            if (investmentGridSort.column === column) {
                // Toggle direction
                investmentGridSort.direction = investmentGridSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                // New column, default to ascending for symbol, descending for numbers
                investmentGridSort.column = column;
                investmentGridSort.direction = column === 'symbol' ? 'asc' : 'desc';
            }
            renderAll();
        }

        function renderBankGrid(tableId, accounts) {
            const gridTable = document.getElementById(tableId);
            const thead = gridTable.querySelector('thead');
            const tbody = gridTable.querySelector('tbody');

            if (!accounts || accounts.length === 0) {
                thead.innerHTML = '';
                tbody.innerHTML = '<tr><td>No bank accounts found.</td></tr>';
                return;
            }

            thead.innerHTML = `<tr>
                <th style="text-align: left">Account Name</th>
                <th style="text-align: left">Type</th>
                <th>Value</th>
            </tr>`;

            let bodyHtml = '';
            let total = 0;

            accounts.forEach(acc => {
                let val = 0;
                let cashPos = acc.holdings.cash;
                if (cashPos) val = cashPos.value;
                total += val;

                const accJson = escapeHtml(JSON.stringify(acc));

                let valCell = '';
                if (cashPos) {
                    const posData = { id: cashPos.id, account_id: acc.id, symbol: 'CASH', type: 'cash', quantity: val, isBankAccount: true };
                    const posJson = escapeHtml(JSON.stringify(posData));
                    valCell = `<span class="clickable-cell" onclick="openPositionModal(${posJson})">${formatNumber(val)} <span class="edit-icon">‚úé</span></span>`;
                } else {
                    const posData = { account_id: acc.id, symbol: 'CASH', type: 'cash', quantity: 0, isBankAccount: true };
                    const posJson = escapeHtml(JSON.stringify(posData));
                    valCell = `<span class="clickable-cell" onclick="openPositionModal(${posJson})">${formatNumber(0)} <span class="edit-icon">‚úé</span></span>`;
                }

                bodyHtml += `<tr>
                    <td><span class="clickable-cell" onclick="openAccountModal('bank', ${accJson})">${acc.name} <span class="edit-icon">‚úé</span></span></td>
                    <td style="text-align: left">${acc.type}</td>
                    <td>${valCell}</td>
                </tr>`;
            });

            bodyHtml += `<tr class="total-row"><td colspan="2">TOTAL</td><td>${formatNumber(total)}</td></tr>`;
            tbody.innerHTML = bodyHtml;
        }

        function renderAssetGrid(tableId, assets) {
            const gridTable = document.getElementById(tableId);
            const thead = gridTable.querySelector('thead');
            const tbody = gridTable.querySelector('tbody');

            if (!assets || assets.length === 0) {
                thead.innerHTML = '';
                tbody.innerHTML = '<tr><td>No fixed assets found.</td></tr>';
                return;
            }

            thead.innerHTML = `<tr>
                <th style="text-align: left">Name</th>
                <th style="text-align: left">Type</th>
                <th>Value</th>
            </tr>`;

            let bodyHtml = '';
            let total = 0;

            assets.forEach(asset => {
                total += asset.value;
                const assetJson = escapeHtml(JSON.stringify(asset));
                bodyHtml += `<tr>
                    <td><span class="clickable-cell" onclick="openAssetModal(${assetJson})">${asset.description || asset.name} <span class="edit-icon">‚úé</span></span></td>
                    <td style="text-align: left">${asset.type}</td>
                    <td><span class="clickable-cell" onclick="openAssetModal(${assetJson})">${formatNumber(asset.value)} <span class="edit-icon">‚úé</span></span></td>
                </tr>`;
            });

            bodyHtml += `<tr class="total-row"><td colspan="2">TOTAL</td><td>${formatNumber(total)}</td></tr>`;
            tbody.innerHTML = bodyHtml;
        }

        // --- Drag and Drop for Columns ---
        function dragStart(ev, id) {
            ev.dataTransfer.setData("text/plain", id);
            ev.dataTransfer.effectAllowed = "move";
        }

        function allowDrop(ev) {
            ev.preventDefault();
        }

        function drop(ev, targetId) {
            ev.preventDefault();
            const draggedId = ev.dataTransfer.getData("text/plain");
            if (String(draggedId) === String(targetId)) return;

            const fromIndex = accountOrder.findIndex(id => String(id) === String(draggedId));
            const toIndex = accountOrder.findIndex(id => String(id) === String(targetId));

            if (fromIndex > -1 && toIndex > -1) {
                const [movedItem] = accountOrder.splice(fromIndex, 1);
                accountOrder.splice(toIndex, 0, movedItem);
                renderAll();
                saveAccountOrder();
            }
        }

        async function saveAccountOrder() {
            // Update display_order for all accounts in the new order
            const updates = accountOrder.map((id, index) => {
                return fetch(`/api/accounts/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ display_order: index })
                });
            });

            try {
                await Promise.all(updates);
                console.log('Account order saved');
            } catch (err) {
                console.error('Error saving account order:', err);
            }
        }

        // --- Helpers ---
        // Normalize ticker strings to the same key format used by scrapers/price messages
        // (underscore-sanitized form for filename compatibility)
        function normalizeTicker(sym) {
            if (!sym && sym !== 0) return sym;
            try {
                return String(sym).toUpperCase().replace(/[^A-Z0-9._-]/g, '_');
            } catch (e) {
                return String(sym).toUpperCase();
            }
        }

        // Percent-encode ticker to match server-side normalized_key format
        // (e.g., GC=F -> GC%3DF)
        function percentEncodeTicker(sym) {
            if (!sym && sym !== 0) return sym;
            try {
                return encodeURIComponent(String(sym).toUpperCase());
            } catch (e) {
                return String(sym).toUpperCase();
            }
        }

        // Safe accessor for currentPrices that falls back to normalized/encoded keys
        // Server's priceCache uses percent-encoded keys (normalized_key), so we try:
        // 1. Direct symbol lookup (e.g., "AAPL")
        // 2. Percent-encoded form (e.g., "GC=F" -> "GC%3DF")
        // 3. Underscore-sanitized form (e.g., "GC=F" -> "GC_F") for legacy compatibility
        function getPriceDataForSymbol(sym) {
            if (!sym && sym !== 0) return undefined;
            // direct lookup
            let data = currentPrices[sym];
            if (data) return data;
            // try percent-encoded form (server's normalized_key)
            const encoded = percentEncodeTicker(sym);
            if (encoded !== sym) {
                data = currentPrices[encoded];
                if (data) return data;
            }
            // try underscore-sanitized form (legacy/filename compatibility)
            const norm = normalizeTicker(sym);
            if (norm !== sym && norm !== encoded) data = currentPrices[norm];
            return data;
        }
        function formatNumber(num, decimals = 2) {
            return new Intl.NumberFormat('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(num);
        }

        function escapeHtml(str) {
            return str.replace(/"/g, '&quot;');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        window.onclick = function (event) {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = "none";
            }
        }

        // Add Escape key support to close modals
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                // Close any open modal
                const modals = document.getElementsByClassName('modal');
                for (let i = 0; i < modals.length; i++) {
                    if (modals[i].style.display === 'block') {
                        modals[i].style.display = 'none';
                        break; // Close only the first open modal
                    }
                }
            }
        });

        // --- Modal Logic ---

        // Account
        function openAccountModal(category, account = null) {
            const modal = document.getElementById('accountModal');
            const form = document.getElementById('accountForm');
            form.reset();
            document.getElementById('accId').value = '';
            document.getElementById('accCategory').value = category || '';
            document.getElementById('btnDeleteAccount').style.display = 'none';
            document.getElementById('accountModalTitle').innerText = 'Add Account';

            if (account) {
                document.getElementById('accountModalTitle').innerText = 'Edit Account';
                document.getElementById('accId').value = account.id;
                document.getElementById('accName').value = account.name;
                document.getElementById('accType').value = account.type;
                document.getElementById('accCategory').value = account.category;
                document.getElementById('btnDeleteAccount').style.display = 'block';
            }
            modal.style.display = 'block';
        }

        document.getElementById('accountForm').onsubmit = async function (e) {
            e.preventDefault();
            const id = document.getElementById('accId').value;
            const body = {
                name: document.getElementById('accName').value,
                type: document.getElementById('accType').value,
                category: document.getElementById('accCategory').value
            };
            const method = id ? 'PUT' : 'POST';
            const url = id ? `/api/accounts/${id}` : '/api/accounts';

            await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            closeModal('accountModal');
            fetchAssets();
        };

        async function deleteAccount() {
            const id = document.getElementById('accId').value;
            showConfirmModal(
                'Delete Account',
                'All positions in this account will also be deleted. Are you sure?',
                async () => {
                    await fetch(`/api/accounts/${id}`, { method: 'DELETE' });
                    closeModal('accountModal');
                    fetchAssets();
                }
            );
        }

        function showConfirmModal(title, message, onConfirm) {
            document.getElementById('confirmModalTitle').innerText = title;
            document.getElementById('confirmModalMessage').innerText = message;
            const okBtn = document.getElementById('confirmModalOk');
            // Hide any open modal (asset/account/position) before showing confirm
            const modalsToHide = ['accountModal', 'positionModal', 'assetModal'];
            let lastOpenModal = null;
            for (const mid of modalsToHide) {
                const m = document.getElementById(mid);
                if (m && m.style.display === 'block') {
                    m.style.display = 'none';
                    lastOpenModal = mid;
                }
            }
            okBtn.onclick = () => {
                closeModal('confirmModal');
                onConfirm();
            };
            // Restore the previous modal if cancel is clicked
            const cancelBtn = document.querySelector('#confirmModal .btn:not(.btn-danger)');
            cancelBtn.onclick = () => {
                closeModal('confirmModal');
                if (lastOpenModal) document.getElementById(lastOpenModal).style.display = 'block';
            };
            document.getElementById('confirmModal').style.display = 'block';
        }

        // Position
        function openPositionModal(pos) {
            const modal = document.getElementById('positionModal');
            const form = document.getElementById('positionForm');
            form.reset();
            document.getElementById('posId').value = '';
            document.getElementById('btnDeletePosition').style.display = 'none';
            document.getElementById('positionModalTitle').innerText = 'Add Position';

            document.getElementById('posAccountId').value = pos.account_id;
            document.getElementById('posQuantity').value = pos.quantity || 0;
            document.getElementById('posSymbol').value = pos.symbol || pos.ticker;

            // Output-only fields (display only, backend determines actual type)
            document.getElementById('posSymbolDisplay').textContent = pos.symbol || pos.ticker;
            // Use account_name if present, otherwise look up
            let accountName = pos.account_name || '';
            if (!accountName && window.lastAssetsData && window.lastAssetsData.accounts) {
                const acc = window.lastAssetsData.accounts.find(a => String(a.id) === String(pos.account_id));
                if (acc) accountName = acc.name;
            }
            document.getElementById('posAccountDisplay').textContent = accountName;

            // Hide Symbol field for cash
            const isCash = pos.type === 'cash';
            const isBankCash = isCash && pos.isBankAccount;
            document.getElementById('posSymbolGroup').style.display = isCash ? 'none' : 'block';
            document.getElementById('btnDeletePosition').style.display = isBankCash ? 'none' : (pos.id ? 'block' : 'none');

            if (pos.id) {
                document.getElementById('positionModalTitle').innerText = 'Edit Position';
                document.getElementById('posId').value = pos.id;
            }
            modal.style.display = 'block';
        }

        document.getElementById('positionForm').onsubmit = async function (e) {
            e.preventDefault();
            const id = document.getElementById('posId').value;
            const symbol = document.getElementById('posSymbol').value;
            const body = {
                account_id: document.getElementById('posAccountId').value,
                // Backend expects ticker; keep symbol for backward compatibility.
                ticker: symbol,
                symbol,
                quantity: parseFloat(document.getElementById('posQuantity').value),
                currency: 'USD'
            };
            const method = id ? 'PUT' : 'POST';
            const url = id ? `/api/positions/${id}` : '/api/positions';

            await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            closeModal('positionModal');
            fetchAssets();
        };

        async function deletePosition() {
            const id = document.getElementById('posId').value;
            if (!confirm('Delete this position?')) return;
            await fetch(`/api/positions/${id}`, { method: 'DELETE' });
            closeModal('positionModal');
            fetchAssets();
        }

        // Asset
        function openAssetModal(asset = null) {
            const modal = document.getElementById('assetModal');
            const form = document.getElementById('assetForm');
            form.reset();
            document.getElementById('assetId').value = '';
            document.getElementById('btnDeleteAsset').style.display = 'none';
            document.getElementById('assetModalTitle').innerText = 'Add Asset';

            if (asset) {
                document.getElementById('assetModalTitle').innerText = 'Edit Asset';
                document.getElementById('assetId').value = asset.id;
                document.getElementById('assetName').value = asset.description || asset.name;
                document.getElementById('assetType').value = asset.type;
                document.getElementById('assetValue').value = asset.value;
                document.getElementById('btnDeleteAsset').style.display = 'block';
            }
            modal.style.display = 'block';
        }

        document.getElementById('assetForm').onsubmit = async function (e) {
            e.preventDefault();
            const id = document.getElementById('assetId').value;
            const body = {
                name: document.getElementById('assetName').value,
                type: document.getElementById('assetType').value,
                value: parseFloat(document.getElementById('assetValue').value),
                currency: 'USD',
                display_order: 0
            };
            const method = id ? 'PUT' : 'POST';
            const url = id ? `/api/fixed_assets/${id}` : '/api/fixed_assets';

            await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            closeModal('assetModal');
            fetchAssets();
        };

        async function deleteAsset() {
            const id = document.getElementById('assetId').value;
            showConfirmModal(
                'Delete Asset',
                'Are you sure you want to delete this asset?',
                async () => {
                    await fetch(`/api/fixed_assets/${id}`, { method: 'DELETE' });
                    closeModal('assetModal');
                    fetchAssets();
                }
            );
        }

        // --- Tabs & Logs ---
        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

            if (tabName === 'Logs') {
                fetchLogs();
            }

            if (tabName === 'Watchlists') {
                refreshWatchlistUI();
            }
        }

        // --- Phase 11: Watchlist Management UI ---

        let _watchlistProvidersCache = null;
        let _watchlistInitializedOnce = false;

        function isWatchlistProviderInitialized(providerId) {
            if (!providerId) return false;
            const initialized = _watchlistProvidersCache && Array.isArray(_watchlistProvidersCache.initialized)
                ? _watchlistProvidersCache.initialized
                : [];
            return initialized.includes(providerId);
        }

        function renderWatchlistNotInitializedState(providerId) {
            const tabsSel = document.getElementById('watchlistTab');
            if (tabsSel) {
                tabsSel.innerHTML = '';
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Provider not initialized';
                tabsSel.appendChild(opt);
            }

            const tbody = document.getElementById('watchlistTickersBody');
            if (tbody) {
                tbody.innerHTML = '';
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="2" style="text-align:center; color:#aaa;">Provider not initialized</td>`;
                tbody.appendChild(tr);
            }

            const meta = document.getElementById('watchlistTickersMeta');
            if (meta) meta.textContent = '';

            setWatchlistStatus(
                `Provider not initialized: ${providerId}. Configure at least one enabled watchlist URL in watchlist_instances and restart scrapers.`,
                true
            );
        }

        function setWatchlistStatus(message, isError = false) {
            const el = document.getElementById('watchlistStatus');
            if (!el) return;
            el.style.color = isError ? '#ffb4a2' : '#aaa';
            el.textContent = message || '';
        }

        async function watchlistFetchJson(url, options = {}) {
            const resp = await fetch(url, {
                ...options,
                headers: {
                    'Content-Type': 'application/json',
                    ...(options.headers || {})
                }
            });
            const text = await resp.text();
            let data;
            try { data = text ? JSON.parse(text) : {}; } catch (e) { data = { error: text || 'Invalid JSON' }; }
            if (!resp.ok) {
                const msg = (data && data.error) ? data.error : `Request failed (${resp.status})`;
                throw new Error(msg);
            }
            return data;
        }

        function getSelectedWatchlistProvider() {
            const sel = document.getElementById('watchlistProvider');
            return sel && sel.value ? sel.value : null;
        }

        function getSelectedWatchlistTab() {
            const sel = document.getElementById('watchlistTab');
            return sel && sel.value ? sel.value : null;
        }

        function renderWatchlistProviderCapabilities(providerId) {
            const el = document.getElementById('watchlistProviderCaps');
            if (!el) return;
            const caps = _watchlistProvidersCache && _watchlistProvidersCache.capabilities
                ? _watchlistProvidersCache.capabilities[providerId]
                : null;

            if (!caps) {
                el.textContent = '';
                return;
            }

            const initialized = Array.isArray(_watchlistProvidersCache.initialized)
                ? _watchlistProvidersCache.initialized.includes(providerId)
                : false;
            const supported = Array.isArray(caps.supportedAssetTypes) ? caps.supportedAssetTypes.join(', ') : '';

            el.innerHTML = `
                <div><strong>${caps.displayName || providerId}</strong> (${providerId})</div>
                <div>Initialized: <strong>${initialized ? 'Yes' : 'No'}</strong></div>
                <div>Multiple watchlists: <strong>${caps.supportsMultipleWatchlists ? 'Yes' : 'No'}</strong></div>
                <div>Requires login: <strong>${caps.requiresLogin ? 'Yes' : 'No'}</strong></div>
                <div>Supported asset types: <strong>${supported || '‚Äî'}</strong></div>
            `;

            const assetSelect = document.getElementById('watchlistAddAssetType');
            if (assetSelect) {
                assetSelect.innerHTML = '';
                const types = Array.isArray(caps.supportedAssetTypes) ? caps.supportedAssetTypes : ['stock'];
                for (const t of types) {
                    const opt = document.createElement('option');
                    opt.value = t;
                    opt.textContent = t;
                    assetSelect.appendChild(opt);
                }
            }
        }

        async function loadWatchlistProviders() {
            setWatchlistStatus('Loading providers...');
            const data = await watchlistFetchJson('/api/watchlist/providers');
            _watchlistProvidersCache = data;

            const sel = document.getElementById('watchlistProvider');
            if (!sel) return;

            const capabilities = data && data.capabilities ? data.capabilities : {};
            const providerIds = Object.keys(capabilities);
            sel.innerHTML = '';
            providerIds.forEach(pid => {
                const cap = capabilities[pid] || {};
                const opt = document.createElement('option');
                opt.value = pid;
                opt.textContent = cap.displayName ? `${cap.displayName} (${pid})` : pid;
                sel.appendChild(opt);
            });

            if (providerIds.length === 0) {
                setWatchlistStatus('No providers registered.', true);
                return;
            }

            setWatchlistStatus(`Loaded ${providerIds.length} provider(s).`);
        }

        async function loadWatchlistTabs() {
            const providerId = getSelectedWatchlistProvider();
            if (!providerId) return;
            const sel = document.getElementById('watchlistTab');
            if (!sel) return;

            sel.innerHTML = '';

            if (!isWatchlistProviderInitialized(providerId)) {
                renderWatchlistNotInitializedState(providerId);
                return;
            }

            try {
                const data = await watchlistFetchJson(`/api/watchlist/${providerId}/tabs`);
                const tabs = (data && Array.isArray(data.tabs)) ? data.tabs : [];
                tabs.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t;
                    opt.textContent = t;
                    sel.appendChild(opt);
                });
                if (tabs.length === 0) {
                    const opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = 'No tabs found';
                    sel.appendChild(opt);
                }
            } catch (e) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Failed to load tabs';
                sel.appendChild(opt);
                throw e;
            }
        }

        async function switchWatchlistTab() {
            const providerId = getSelectedWatchlistProvider();
            const watchlist = getSelectedWatchlistTab();
            if (!providerId || !watchlist) return;

            if (!isWatchlistProviderInitialized(providerId)) {
                renderWatchlistNotInitializedState(providerId);
                return;
            }

            setWatchlistStatus(`Switching to tab: ${watchlist}...`);
            await watchlistFetchJson(`/api/watchlist/${providerId}/switch`, {
                method: 'POST',
                body: JSON.stringify({ watchlist })
            });
            setWatchlistStatus(`Switched to tab: ${watchlist}`);
        }

        async function loadWatchlistTickers() {
            const providerId = getSelectedWatchlistProvider();
            if (!providerId) return;

            if (!isWatchlistProviderInitialized(providerId)) {
                renderWatchlistNotInitializedState(providerId);
                return;
            }

            setWatchlistStatus('Loading tickers...');
            const data = await watchlistFetchJson(`/api/watchlist/${providerId}/tickers`);
            const tickers = (data && Array.isArray(data.tickers)) ? data.tickers : [];

            const meta = document.getElementById('watchlistTickersMeta');
            if (meta) {
                const tab = getSelectedWatchlistTab();
                meta.textContent = `${tickers.length} ticker(s)${tab ? ` (tab: ${tab})` : ''}`;
            }

            const tbody = document.getElementById('watchlistTickersBody');
            if (!tbody) return;
            tbody.innerHTML = '';

            tickers.forEach(t => {
                const tr = document.createElement('tr');
                const safe = String(t || '').toUpperCase();
                tr.innerHTML = `
                    <td style="text-align:left;">${safe}</td>
                    <td style="text-align:center;">
                        <button class="btn btn-danger" onclick="deleteWatchlistTicker('${safe}')">Delete</button>
                    </td>
                `;
                tbody.appendChild(tr);
            });

            if (tickers.length === 0) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="2" style="text-align:center; color:#aaa;">No tickers</td>`;
                tbody.appendChild(tr);
            }

            setWatchlistStatus('Tickers loaded.');
        }

        async function addWatchlistTicker() {
            const providerId = getSelectedWatchlistProvider();
            if (!providerId) return;

            if (!isWatchlistProviderInitialized(providerId)) {
                renderWatchlistNotInitializedState(providerId);
                return;
            }

            const tickerEl = document.getElementById('watchlistAddTicker');
            const assetTypeEl = document.getElementById('watchlistAddAssetType');
            const ticker = tickerEl ? tickerEl.value.trim().toUpperCase() : '';
            const assetType = assetTypeEl ? assetTypeEl.value : 'stock';
            const watchlist = getSelectedWatchlistTab();

            if (!ticker) {
                setWatchlistStatus('Ticker is required.', true);
                return;
            }

            setWatchlistStatus(`Adding ${ticker}...`);
            await watchlistFetchJson(`/api/watchlist/${providerId}/add`, {
                method: 'POST',
                body: JSON.stringify({ ticker, assetType, watchlist })
            });

            if (tickerEl) tickerEl.value = '';
            setWatchlistStatus(`Added ${ticker}.`);
            await loadWatchlistTickers();
        }

        async function deleteWatchlistTicker(ticker) {
            const providerId = getSelectedWatchlistProvider();
            const watchlist = getSelectedWatchlistTab();
            if (!providerId || !ticker) return;

            if (!isWatchlistProviderInitialized(providerId)) {
                renderWatchlistNotInitializedState(providerId);
                return;
            }

            showConfirmModal(
                'Delete Ticker',
                `Delete ${ticker} from watchlist?`,
                async () => {
                    try {
                        setWatchlistStatus(`Deleting ${ticker}...`);
                        await watchlistFetchJson(`/api/watchlist/${providerId}/delete`, {
                            method: 'POST',
                            body: JSON.stringify({ ticker, watchlist })
                        });
                        setWatchlistStatus(`Deleted ${ticker}.`);
                        await loadWatchlistTickers();
                    } catch (e) {
                        setWatchlistStatus(e.message || 'Delete failed', true);
                    }
                }
            );
        }

        async function onWatchlistProviderChanged() {
            const providerId = getSelectedWatchlistProvider();
            if (!providerId) return;

            try {
                renderWatchlistProviderCapabilities(providerId);

                if (!isWatchlistProviderInitialized(providerId)) {
                    renderWatchlistNotInitializedState(providerId);
                    return;
                }

                await loadWatchlistTabs();

                // Best effort: switch to the first tab so tickers reflect the tab selection.
                const firstTab = getSelectedWatchlistTab();
                if (firstTab) {
                    try { await switchWatchlistTab(); } catch (e) { }
                }
                await loadWatchlistTickers();
            } catch (e) {
                setWatchlistStatus(e.message || 'Failed to load provider', true);
            }
        }

        async function refreshWatchlistUI() {
            try {
                if (!_watchlistInitializedOnce) {
                    _watchlistInitializedOnce = true;
                }
                await loadWatchlistProviders();
                const providerId = getSelectedWatchlistProvider();
                if (providerId) {
                    renderWatchlistProviderCapabilities(providerId);

                    if (!isWatchlistProviderInitialized(providerId)) {
                        renderWatchlistNotInitializedState(providerId);
                        return;
                    }

                    await loadWatchlistTabs();
                    const tab = getSelectedWatchlistTab();
                    if (tab) {
                        try { await switchWatchlistTab(); } catch (e) { }
                    }
                    await loadWatchlistTickers();
                }
            } catch (e) {
                setWatchlistStatus(e.message || 'Failed to refresh watchlists', true);
            }
        }

        async function fetchLogs() {
            try {
                const response = await fetch('/api/logs');
                const files = await response.json();
                const tbody = document.getElementById('log-list');
                tbody.innerHTML = '';
                files.forEach(file => {
                    const tr = document.createElement('tr');
                    tr.style.cursor = 'pointer';
                    tr.onclick = () => viewLog(file.name);
                    tr.onmouseover = () => tr.style.backgroundColor = '#333';
                    tr.onmouseout = () => tr.style.backgroundColor = 'transparent';

                    const date = new Date(file.timestamp).toLocaleString();
                    const size = (file.size / 1024).toFixed(1) + ' KB';

                    tr.innerHTML = `
                        <td style="padding: 5px; border-bottom: 1px solid #333; word-break: break-all;">${file.name}</td>
                        <td style="padding: 5px; border-bottom: 1px solid #333;">${date}</td>
                        <td style="padding: 5px; border-bottom: 1px solid #333; text-align: right;">${size}</td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (error) {
                console.error('Error fetching logs:', error);
            }
        }

        async function viewLog(filename) {
            try {
                const viewer = document.getElementById('log-viewer-pane');
                if (filename.toLowerCase().endsWith('.png')) {
                    // Display image
                    viewer.innerHTML = `<img src="/api/logs/${encodeURIComponent(filename)}" alt="${filename}" style="max-width:100%; max-height:80vh; display:block; margin:auto; background:#222; border-radius:8px;" />`;
                } else {
                    const response = await fetch(`/api/logs/${filename}`);
                    if (filename.endsWith('.json')) {
                        const data = await response.json();
                        viewer.innerText = JSON.stringify(data, null, 2);
                    } else {
                        const text = await response.text();
                        viewer.innerText = text;
                    }
                }
            } catch (error) {
                document.getElementById('log-viewer-pane').innerText = 'Error loading file: ' + error;
            }
        }

        // --- Resizing Logic ---

        // 1. Split Pane Resizer
        const paneResizer = document.getElementById('pane-resizer');
        const leftPane = document.getElementById('log-list-pane');
        const rightPane = document.getElementById('log-viewer-pane');
        const logsContainer = document.getElementById('logs-container');

        if (paneResizer) {
            let x = 0;
            let leftWidth = 0;

            const onMouseDownPane = function (e) {
                x = e.clientX;
                leftWidth = leftPane.getBoundingClientRect().width;

                document.addEventListener('mousemove', onMouseMovePane);
                document.addEventListener('mouseup', onMouseUpPane);

                // Visual feedback
                paneResizer.style.backgroundColor = '#666';
            };

            const onMouseMovePane = function (e) {
                const dx = e.clientX - x;
                const containerWidth = logsContainer.getBoundingClientRect().width;
                const newLeftWidth = ((leftWidth + dx) / containerWidth) * 100;

                // Limits (10% to 90%)
                if (newLeftWidth > 10 && newLeftWidth < 90) {
                    leftPane.style.width = `${newLeftWidth}%`;
                }

                document.body.style.cursor = 'col-resize';
                leftPane.style.userSelect = 'none';
                leftPane.style.pointerEvents = 'none';
                rightPane.style.userSelect = 'none';
                rightPane.style.pointerEvents = 'none';
            };

            const onMouseUpPane = function () {
                document.removeEventListener('mousemove', onMouseMovePane);
                document.removeEventListener('mouseup', onMouseUpPane);

                document.body.style.cursor = 'default';
                leftPane.style.removeProperty('user-select');
                leftPane.style.removeProperty('pointer-events');
                rightPane.style.removeProperty('user-select');
                rightPane.style.removeProperty('pointer-events');
                paneResizer.style.backgroundColor = '#444';
            };

            paneResizer.addEventListener('mousedown', onMouseDownPane);
        }

        // 2. Table Column Resizer
        function createResizableColumn(col, resizer) {
            let x = 0;
            let w = 0;

            const onMouseDownCol = function (e) {
                e.stopPropagation(); // Prevent bubbling
                x = e.clientX;
                w = col.getBoundingClientRect().width;

                document.addEventListener('mousemove', onMouseMoveCol);
                document.addEventListener('mouseup', onMouseUpCol);
                resizer.style.backgroundColor = '#888';
            };

            const onMouseMoveCol = function (e) {
                const dx = e.clientX - x;
                // Set width in pixels to override percentage
                col.style.width = `${w + dx}px`;
            };

            const onMouseUpCol = function () {
                document.removeEventListener('mousemove', onMouseMoveCol);
                document.removeEventListener('mouseup', onMouseUpCol);
                resizer.style.backgroundColor = '#555';
            };

            resizer.addEventListener('mousedown', onMouseDownCol);
        }

        // Initialize column resizers
        ['col-file'].forEach(id => {
            const th = document.getElementById(id);
            if (th) {
                const resizer = document.createElement('div');
                resizer.style.width = '5px';
                resizer.style.height = '100%';
                resizer.style.position = 'absolute';
                resizer.style.top = '0';
                resizer.style.right = '0';
                resizer.style.cursor = 'col-resize';
                resizer.style.backgroundColor = '#555'; // Visible handle
                resizer.style.userSelect = 'none';
                resizer.style.zIndex = '5';

                th.appendChild(resizer);
                createResizableColumn(th, resizer);
            }
        });

        // --- Settings Dropdown ---
        function toggleSettingsDropdown() {
            const dropdown = document.getElementById('settingsDropdown');
            const isVisible = dropdown.style.display === 'block';

            // Hide dropdown if visible
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                // Show dropdown
                dropdown.style.display = 'block';
            }
        }

        function showLogs() {
            const dropdown = document.getElementById('settingsDropdown');
            dropdown.style.display = 'none';

            // Open logs modal
            document.getElementById('logsModal').style.display = 'block';

            // Fetch logs if not already loaded
            fetchLogs();
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const dropdown = document.getElementById('settingsDropdown');
            const settingsBtn = document.getElementById('settingsBtn');

            if (!settingsBtn.contains(event.target) && !dropdown.contains(event.target)) {
                dropdown.style.display = 'none';
            }
        });

        // --- Settings ---
        function openSettingsModal() {
            const dropdown = document.getElementById('settingsDropdown');
            dropdown.style.display = 'none'; // Close dropdown when opening modal

            const modal = document.getElementById('settingsModal');
            // Load current settings (from localStorage or defaults)
            loadSettings();
            modal.style.display = 'block';
        }

        function loadSettings() {
            // Load settings from localStorage or set defaults
            const autoRefresh = localStorage.getItem('autoRefresh') !== 'false'; // default true
            const refreshInterval = localStorage.getItem('refreshInterval') || '60';
            const theme = localStorage.getItem('theme') || 'dark';

            document.getElementById('autoRefresh').checked = autoRefresh;
            document.getElementById('refreshInterval').value = refreshInterval;
            document.getElementById('theme').value = theme;

            // Phase 7: Update metadata stats when modal opens
            updateMetadataStats();
        }

        function saveSettings() {
            // Save settings to localStorage
            const autoRefresh = document.getElementById('autoRefresh').checked;
            const refreshInterval = document.getElementById('refreshInterval').value;
            const theme = document.getElementById('theme').value;

            localStorage.setItem('autoRefresh', autoRefresh);
            localStorage.setItem('refreshInterval', refreshInterval);
            localStorage.setItem('theme', theme);

            // Apply settings immediately
            applySettings();

            closeModal('settingsModal');

            // Show success message
            alert('Settings saved successfully!');
        }

        function applySettings() {
            const theme = localStorage.getItem('theme') || 'dark';
            const autoRefresh = localStorage.getItem('autoRefresh') !== 'false';
            const refreshInterval = parseInt(localStorage.getItem('refreshInterval') || '60');

            // Apply theme (basic implementation - could be expanded)
            if (theme === 'light') {
                document.body.style.backgroundColor = '#ffffff';
                document.body.style.color = '#000000';
            } else {
                document.body.style.backgroundColor = '#121212';
                document.body.style.color = '#e0e0e0';
            }

            // Apply auto-refresh
            if (autoRefresh && window.refreshIntervalId) {
                clearInterval(window.refreshIntervalId);
            }
            if (autoRefresh) {
                window.refreshIntervalId = setInterval(fetchAssets, refreshInterval * 1000);
            }
        }

        function exportData() {
            // Basic data export functionality
            if (confirm('Export all account and position data?')) {
                fetch('/api/export')
                    .then(response => response.json())
                    .then(data => {
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `wealth-tracker-export-${new Date().toISOString().split('T')[0]}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    })
                    .catch(err => alert('Export failed: ' + err.message));
            }
        }

        function importData(fileInput) {
            const file = fileInput.files[0];
            if (!file) return;

            if (!confirm('Import data from file? This will REPLACE all existing account and position data. Continue?')) {
                // Reset file input
                fileInput.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const importData = JSON.parse(e.target.result);

                    // Validate the data structure
                    if (!importData.data || !importData.data.accounts || !importData.data.positions) {
                        throw new Error('Invalid file format. Expected exported wealth-tracker data.');
                    }

                    // Send to server for import
                    fetch('/api/import', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(importData)
                    })
                        .then(response => response.json())
                        .then(result => {
                            if (result.success) {
                                alert('Data imported successfully!');
                                // Refresh the dashboard data
                                fetchAssets();
                                closeModal('settingsModal');
                            } else {
                                alert('Import failed: ' + (result.error || 'Unknown error'));
                            }
                        })
                        .catch(err => {
                            alert('Import failed: ' + err.message);
                        });
                } catch (err) {
                    alert('Failed to parse file: ' + err.message);
                }
            };

            reader.readAsText(file);
            // Reset file input
            fileInput.value = '';
        }

        function clearCache() {
            if (confirm('Clear all cached data? This will force a fresh reload of all data.')) {
                localStorage.clear();
                sessionStorage.clear();
                // Clear any cached ticker data
                tickerList = [];
                tickerData = [];
                tickerLookup = {};
                // Reload the page to apply changes
                location.reload();
            }
        }

        // ========== PHASE 8.4: PERFORMANCE METRICS FUNCTIONS ==========

        /**
         * Load and display performance metrics
         */
        async function loadPerformanceMetrics() {
            try {
                // Fetch metrics summary
                const summaryResponse = await fetch('/api/metrics/summary');
                if (!summaryResponse.ok) {
                    throw new Error(`HTTP ${summaryResponse.status}`);
                }
                const summaryData = await summaryResponse.json();

                // Fetch success rate
                const successResponse = await fetch('/api/metrics/success-rate?days=7');
                const successData = successResponse.ok ? await successResponse.json() : { successRate: 0 };

                // Update metrics display
                updateMetricsDisplay(summaryData, successData);

                // Update file status display
                updateFileStatusDisplay(summaryData.fileRefreshStatus || []);

            } catch (error) {
                console.error('Error loading performance metrics:', error);
                document.getElementById('metric-health').textContent = '‚ö†Ô∏è Error';
                document.getElementById('metric-health').style.color = '#ff6b6b';
            }
        }

        /**
         * Update the metrics display panel
         */
        function updateMetricsDisplay(summaryData, successData) {
            const summary = summaryData.summary || {};

            // Health status
            const healthEl = document.getElementById('metric-health');
            const overallHealth = summaryData.fileRefreshStatus?.every(s => s.last_refresh_status === 'SUCCESS');
            if (overallHealth) {
                healthEl.textContent = '‚úÖ Healthy';
                healthEl.style.color = '#4ade80';
            } else if (summaryData.fileRefreshStatus?.some(s => s.last_refresh_status === 'SUCCESS')) {
                healthEl.textContent = '‚ö†Ô∏è Degraded';
                healthEl.style.color = '#fbbf24';
            } else {
                healthEl.textContent = '‚ùå Issues';
                healthEl.style.color = '#ff6b6b';
            }

            // Success rate
            const successRateEl = document.getElementById('metric-success-rate');
            const successRate = successData.successRate || 0;
            successRateEl.textContent = `${successRate}%`;
            successRateEl.style.color = successRate >= 90 ? '#4ade80' : successRate >= 70 ? '#fbbf24' : '#ff6b6b';

            // Total symbols
            document.getElementById('metric-total-symbols').textContent =
                (summary.totalSymbols || 0).toLocaleString();

            // Recent errors
            const errorsEl = document.getElementById('metric-recent-errors');
            const recentErrors = summary.recentErrors || 0;
            errorsEl.textContent = recentErrors.toString();
            errorsEl.style.color = recentErrors === 0 ? '#4ade80' : recentErrors < 10 ? '#fbbf24' : '#ff6b6b';

            // Last updated
            document.getElementById('metric-last-updated').textContent =
                new Date(summaryData.timestamp).toLocaleString();
        }

        /**
         * Update the file sync status display
         */
        function updateFileStatusDisplay(fileStatus) {
            const container = document.getElementById('fileStatusList');
            if (!fileStatus || fileStatus.length === 0) {
                container.innerHTML = '<div style="color: #888; text-align: center; padding: 10px;">No sync data available</div>';
                return;
            }

            const statusIcons = {
                'SUCCESS': '‚úÖ',
                'FAILED': '‚ùå',
                'IN_PROGRESS': 'üîÑ'
            };

            container.innerHTML = fileStatus.map(status => {
                const icon = statusIcons[status.last_refresh_status] || '‚ùì';
                const duration = status.last_refresh_duration_ms
                    ? `${(status.last_refresh_duration_ms / 1000).toFixed(1)}s`
                    : '‚Äî';
                const lastRefresh = status.last_refresh_at
                    ? new Date(status.last_refresh_at).toLocaleString()
                    : 'Never';
                const added = status.tickers_added || 0;
                const updated = status.tickers_updated || 0;

                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid #444;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>${icon}</span>
                            <span style="color: #e0e0e0; font-weight: bold;">${status.file_type}</span>
                        </div>
                        <div style="text-align: right; color: #888; font-size: 1.6em;">
                            <div><span style="color: #aaa; font-size: 0.6em;">Added/Updated | Duration:</span> +${added} / ~${updated} | ${duration}</div>
                            <div style="font-size: 1em;"><span style="color: #aaa; font-size: 0.6em;">Last Sync:</span> ${lastRefresh}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Load metrics when settings modal opens
        const originalOpenSettingsModal = openSettingsModal;
        openSettingsModal = function () {
            originalOpenSettingsModal();
            loadPerformanceMetrics();
        };

        // ========== PHASE 7: DASHBOARD INTEGRATION FUNCTIONS ==========

        /**
         * Fetch and display metadata statistics from the API
         */
        async function updateMetadataStats() {
            try {
                console.log('[updateMetadataStats] Fetching statistics...');
                const response = await fetch('/api/autocomplete/stats');
                console.log('[updateMetadataStats] Response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[updateMetadataStats] Data received:', data);

                const summary = data.summary || {};

                // Update statistics display
                const totalElement = document.getElementById('stat-total');
                const withElement = document.getElementById('stat-with');
                const withoutElement = document.getElementById('stat-without');
                const completionElement = document.getElementById('stat-completion');

                // Queue metrics elements
                const queueSizeElement = document.getElementById('stat-queue-size');
                const queueTimeElement = document.getElementById('stat-queue-time');

                // Processing metrics elements  
                const recentUpdatesElement = document.getElementById('stat-recent-updates');
                const avgTimeElement = document.getElementById('stat-avg-time');

                const totalValue = summary.total_symbols || 0;
                const withValue = summary.with_metadata || 0;
                const withoutValue = summary.without_metadata || 0;
                const completionValue = (summary.completion_percentage || 0).toFixed(1);

                console.log('[updateMetadataStats] Setting values:', { totalValue, withValue, withoutValue, completionValue });

                if (totalElement) {
                    totalElement.textContent = totalValue;
                    console.log('[updateMetadataStats] stat-total element text set to:', totalElement.textContent);
                }
                if (withElement) {
                    withElement.textContent = withValue;
                    console.log('[updateMetadataStats] stat-with element text set to:', withElement.textContent);
                }
                if (withoutElement) {
                    withoutElement.textContent = withoutValue;
                    console.log('[updateMetadataStats] stat-without element text set to:', withoutElement.textContent);
                }
                if (completionElement) {
                    completionElement.textContent = completionValue;
                    console.log('[updateMetadataStats] stat-completion element text set to:', completionElement.textContent);
                }

                // Update queue metrics
                const queue = data.queue || {};
                if (queueSizeElement) {
                    queueSizeElement.textContent = queue.size || 0;
                }
                if (queueTimeElement) {
                    const estMinutes = queue.estimated_completion_minutes || 0;
                    queueTimeElement.textContent = estMinutes > 0 ? `${estMinutes} min` : '0 min';
                }

                // Update processing metrics
                const processing = data.processing || {};
                if (recentUpdatesElement) {
                    recentUpdatesElement.textContent = processing.recent_updates_last_hour || 0;
                }
                if (avgTimeElement) {
                    const avgTime = processing.avg_processing_time_seconds || 0;
                    avgTimeElement.textContent = avgTime > 0 ? `${avgTime}s` : '0s';
                }

                // Update status message
                const completion = summary.completion_percentage || 0;
                const totalSymbols = summary.total_symbols || 0;
                let statusMsg = '';

                if (totalSymbols === 0) {
                    statusMsg = '‚ÑπÔ∏è No symbols in registry yet.';
                } else if (completion >= 95) {
                    statusMsg = '‚úÖ Metadata population nearly complete!';
                } else if (completion >= 80) {
                    statusMsg = 'üìä Metadata population in progress...';
                } else if (completion >= 50) {
                    statusMsg = 'üîÑ Metadata population in progress...';
                } else if (completion > 0) {
                    statusMsg = '‚è≥ Metadata population started...';
                } else {
                    statusMsg = '‚ÑπÔ∏è Ready to start metadata population.';
                }
                const statusElement = document.getElementById('metadataStatus');
                if (statusElement) statusElement.textContent = statusMsg;
                console.log('[updateMetadataStats] Status set to:', statusMsg);

            } catch (error) {
                console.error('[updateMetadataStats] Error:', error.message);
                const statusElement = document.getElementById('metadataStatus');
                if (statusElement) {
                    statusElement.textContent = '‚ö†Ô∏è Could not load statistics: ' + error.message;
                }
            }
        }

        /**
         * Trigger metadata refresh for all symbols
         */
        async function refreshMetadata() {
            const btn = document.getElementById('btnRefreshMetadata');
            const originalText = btn.textContent;

            try {
                btn.disabled = true;
                btn.textContent = '‚è≥ Refreshing metadata...';

                // Call API to get pending symbols and mark them for refresh
                const pendingResponse = await fetch('/api/autocomplete/pending?limit=100');
                if (!pendingResponse.ok) throw new Error('Failed to get pending symbols');

                const pendingData = await pendingResponse.json();
                const symbols = pendingData.pending || [];

                if (symbols.length === 0) {
                    alert('‚úÖ All symbols have metadata! No refresh needed.');
                    btn.textContent = originalText;
                    btn.disabled = false;
                    return;
                }

                // Bulk refresh the pending symbols
                const refreshResponse = await fetch('/api/autocomplete/bulk-refresh', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbols })
                });

                if (!refreshResponse.ok) throw new Error('Failed to refresh metadata');

                const refreshData = await refreshResponse.json();
                alert(`‚úÖ Queued ${refreshData.symbols_refreshed} symbols for metadata refresh!`);

                // Update stats immediately
                await updateMetadataStats();

            } catch (error) {
                console.error('Error refreshing metadata:', error);
                alert('‚ùå Error refreshing metadata: ' + error.message);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        /**
         * Trigger cleanup of expired securities
         */
        async function cleanupExpired() {
            const btn = document.getElementById('btnCleanupExpired');
            const originalText = btn.textContent;

            if (!confirm('This will remove symbols with no metadata and no holdings. Continue?')) {
                return;
            }

            try {
                btn.disabled = true;
                btn.textContent = '‚è≥ Cleaning up...';

                // Call cleanup API endpoint
                const response = await fetch('/api/cleanup/cleanup', {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.symbols_deleted > 0) {
                    alert(`‚úÖ Cleanup complete!\n\nRemoved: ${data.symbols_deleted} symbols\n\n` +
                        data.by_type.map(t => `${t.type}: ${t.count}`).join('\n'));
                } else {
                    alert('‚ÑπÔ∏è No expired symbols to clean up.');
                }

                // Update statistics after cleanup
                await updateMetadataStats();

            } catch (error) {
                console.error('Error during cleanup:', error);
                alert('‚ùå Error during cleanup: ' + error.message);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        /**
         * Lookup symbol metadata from autocomplete API (Phase 7)
         */
        async function lookupSymbolMetadata() {
            const symbol = document.getElementById('newSymbol').value.trim().toUpperCase();
            const statusEl = document.getElementById('symbolLookupStatus');
            const displayEl = document.getElementById('symbolMetadataDisplay');
            const btn = document.getElementById('btnLookupSymbol');

            // Clear previous status
            statusEl.style.display = 'none';
            displayEl.style.display = 'none';

            if (!symbol) {
                return;
            }

            try {
                btn.disabled = true;
                statusEl.textContent = 'üîç Checking symbol...';
                statusEl.style.display = 'block';

                const response = await fetch(`/api/autocomplete/details/${symbol}`);

                if (!response.ok) {
                    if (response.status === 404) {
                        statusEl.textContent = '‚ö†Ô∏è Symbol not recognized. Will add as new stock.';
                        displayEl.style.display = 'none';
                    } else {
                        statusEl.textContent = '‚ùå Error checking symbol.';
                    }
                    statusEl.style.display = 'block';
                    return;
                }

                const data = await response.json();

                // Populate metadata display
                document.getElementById('symbolMetadataName').textContent = data.name || '‚Äî';
                // Show detected type (auto-determined by backend from treasury registry + Yahoo metadata)
                const detectedType = data.detectedType || data.type || 'STOCK';
                document.getElementById('symbolMetadataType').textContent = detectedType.toUpperCase();
                document.getElementById('symbolMetadataExchange').textContent = data.exchange || '‚Äî';
                document.getElementById('symbolMetadataVerified').textContent = data.verified ? '‚úÖ Yes' : '‚ö†Ô∏è Unverified';

                // Store detected type in hidden input (backend auto-detected)
                document.getElementById('newSymbolType').value = detectedType.toLowerCase();

                displayEl.style.display = 'block';
                statusEl.textContent = '‚è≥ Fetching current price...';

                // Fetch current price - pass type so bonds trigger scrape daemon
                try {
                    const priceResponse = await fetch('/api/fetch-price', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ticker: symbol, type: detectedType.toLowerCase() })
                    });

                    if (priceResponse.ok) {
                        const priceData = await priceResponse.json();
                        if (priceData.isBond) {
                            // Bond prices are fetched asynchronously by scrape daemon
                            statusEl.textContent = priceData.triggered
                                ? '‚úÖ Bond added! Price will update shortly via scraper.'
                                : '‚ö†Ô∏è Bond added, but scraper trigger failed.';
                        } else {
                            statusEl.textContent = `‚úÖ Found! Current price: $${priceData.price.toFixed(2)}`;
                        }
                    } else {
                        statusEl.textContent = '‚úÖ Symbol found! (Price unavailable)';
                    }
                } catch (priceError) {
                    console.warn('Price fetch failed:', priceError);
                    statusEl.textContent = '‚úÖ Symbol found! (Price fetch failed)';
                }

            } catch (error) {
                console.error('Error looking up symbol:', error);
                statusEl.textContent = '‚ùå Error: ' + error.message;
                statusEl.style.display = 'block';
            } finally {
                btn.disabled = false;
            }
        }

        // ========== END PHASE 7 ==========

        // ========== PHASE 8.2: SCHEDULED METADATA REFRESH ==========

        // Global scheduler instance
        let metadataRefreshScheduler = null;

        /**
         * Initialize the metadata refresh scheduler
         */
        function initializeScheduler() {
            // MetadataRefreshScheduler class will be loaded from scheduler.js
            if (typeof MetadataRefreshScheduler !== 'undefined') {
                metadataRefreshScheduler = new MetadataRefreshScheduler();

                // Set initial UI state
                updateScheduleStatus();

                console.log('[Dashboard] Metadata refresh scheduler initialized');

                // Update schedule status every minute
                setInterval(updateScheduleStatus, 60000);
            } else {
                console.error('[Dashboard] MetadataRefreshScheduler class not available');
            }
        }

        /**
         * Update the schedule status display
         */
        function updateScheduleStatus() {
            if (!metadataRefreshScheduler) return;

            const status = metadataRefreshScheduler.getStatus();
            const statusEl = document.getElementById('schedule-status');
            const nextEl = document.getElementById('schedule-next');
            const lastEl = document.getElementById('schedule-last');

            // Update status
            statusEl.textContent = status.enabled ? '‚úÖ Enabled' : '‚è∏Ô∏è Disabled';
            statusEl.style.color = status.enabled ? '#4ade80' : '#f87171';

            // Update next refresh time
            if (status.nextRefresh) {
                const nextTime = new Date(status.nextRefresh);
                const timeUntil = metadataRefreshScheduler.getTimeUntilNextRefresh();
                nextEl.textContent = `${nextTime.toLocaleTimeString()} (in ${timeUntil})`;
            } else {
                nextEl.textContent = '‚Äî';
            }

            // Update last refresh time
            if (status.lastRefresh) {
                const lastTime = new Date(status.lastRefresh);
                lastEl.textContent = lastTime.toLocaleString();
            } else {
                lastEl.textContent = '‚Äî';
            }

            // Update dropdown to match current schedule
            const selectEl = document.getElementById('refreshSchedule');
            if (selectEl) {
                const currentValue = status.interval ? status.interval.toString() : 'null';
                selectEl.value = currentValue;
            }
        }

        /**
         * Handle refresh schedule change
         */
        document.addEventListener('DOMContentLoaded', function () {
            const scheduleSelect = document.getElementById('refreshSchedule');
            if (scheduleSelect) {
                scheduleSelect.addEventListener('change', function () {
                    if (!metadataRefreshScheduler) return;

                    const value = this.value === 'null' ? null : parseInt(this.value);
                    metadataRefreshScheduler.start(value);
                    updateScheduleStatus();

                    // Show notification
                    const label = metadataRefreshScheduler.getIntervalLabel(value);
                    console.log(`[Dashboard] Metadata refresh schedule changed to: ${label}`);
                });
            }
        });

        // ========== END PHASE 8.2 ==========

        // ========== PHASE 8.3: ADVANCED STATISTICS FILTERING ==========

        // Global statistics filter instance
        let statisticsFilter = null;

        /**
         * Initialize the statistics filter
         */
        function initializeStatisticsFilter() {
            if (typeof StatisticsFilter !== 'undefined') {
                statisticsFilter = new StatisticsFilter();

                // Load available types and populate buttons
                statisticsFilter.loadAvailableTypes().then(types => {
                    populateTypeFilterButtons(types);
                    console.log('[Dashboard] Statistics filter initialized with', types.length, 'types');
                });
            } else {
                console.error('[Dashboard] StatisticsFilter class not available');
            }
        }

        /**
         * Populate type filter buttons
         */
        function populateTypeFilterButtons(types) {
            const container = document.getElementById('typeFilterButtons');
            if (!container) return;

            container.innerHTML = '';

            types.forEach(type => {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.style.padding = '6px 10px';
                btn.style.fontSize = '0.85em';
                btn.style.backgroundColor = '#3a3a3a';
                btn.style.color = '#e0e0e0';
                btn.style.border = '1px solid #555';
                btn.textContent = type;

                btn.onclick = () => {
                    selectTypeFilter(type);
                    btn.style.backgroundColor = '#0d6efd';
                    btn.style.color = 'white';

                    // Deselect other buttons
                    container.querySelectorAll('button').forEach(b => {
                        if (b !== btn) {
                            b.style.backgroundColor = '#3a3a3a';
                            b.style.color = '#e0e0e0';
                            b.style.borderColor = '#555';
                        }
                    });
                };

                container.appendChild(btn);
            });
        }

        /**
         * Select a type filter and display its stats
         */
        async function selectTypeFilter(type) {
            if (!statisticsFilter) return;

            statisticsFilter.selectedType = type;
            statisticsFilter.save();

            try {
                const stats = await statisticsFilter.getTypeStats(type);
                if (!stats) {
                    console.error('[Dashboard] Failed to fetch stats for type:', type);
                    return;
                }

                // Update UI
                document.getElementById('typeStats').style.display = 'block';
                document.getElementById('typeStatsLabel').textContent = `Type: ${type}`;
                document.getElementById('typeStat-total').textContent = stats.total_symbols;
                document.getElementById('typeStat-with').textContent = stats.with_metadata;
                document.getElementById('typeStat-without').textContent = stats.without_metadata;
                document.getElementById('typeStat-completion').textContent = stats.completion_percentage;

                console.log('[Dashboard] Type stats loaded:', stats);
            } catch (error) {
                console.error('[Dashboard] Error selecting type:', error);
            }
        }

        /**
         * Clear type filter
         */
        function clearTypeFilter() {
            if (!statisticsFilter) return;

            statisticsFilter.selectedType = null;
            statisticsFilter.save();

            document.getElementById('typeStats').style.display = 'none';

            // Deselect all type buttons
            document.getElementById('typeFilterButtons').querySelectorAll('button').forEach(btn => {
                btn.style.backgroundColor = '#3a3a3a';
                btn.style.color = '#e0e0e0';
                btn.style.borderColor = '#555';
            });

            console.log('[Dashboard] Type filter cleared');
        }

        /**
         * Refresh metadata for selected type
         */
        async function refreshSelectedType() {
            if (!statisticsFilter || !statisticsFilter.selectedType) return;

            const type = statisticsFilter.selectedType;
            const btn = document.getElementById('btnRefreshType');
            const originalText = btn.textContent;

            try {
                btn.disabled = true;
                btn.textContent = '‚è≥ Refreshing...';

                const result = await statisticsFilter.refreshType(type);
                if (result) {
                    btn.textContent = '‚úÖ Refreshed!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                        // Reload stats
                        selectTypeFilter(type);
                    }, 1500);
                } else {
                    throw new Error('Failed to refresh');
                }
            } catch (error) {
                console.error('[Dashboard] Error refreshing type:', error);
                btn.textContent = '‚ùå Error';
                btn.disabled = false;
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }
        }

        /**
         * Reset metadata for selected type
         */
        async function resetSelectedType() {
            if (!statisticsFilter || !statisticsFilter.selectedType) return;

            const type = statisticsFilter.selectedType;
            const confirmed = confirm(`Reset all ${type} metadata? This will archive and clear all metadata for this type.`);
            if (!confirmed) return;

            const btn = document.getElementById('btnResetType');
            const originalText = btn.textContent;

            try {
                btn.disabled = true;
                btn.textContent = '‚è≥ Resetting...';

                const result = await statisticsFilter.resetType(type);
                if (result) {
                    btn.textContent = '‚úÖ Reset!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                        // Reload stats
                        selectTypeFilter(type);
                        // Also refresh overall stats
                        updateMetadataStats();
                    }, 1500);
                } else {
                    throw new Error('Failed to reset');
                }
            } catch (error) {
                console.error('[Dashboard] Error resetting type:', error);
                btn.textContent = '‚ùå Error';
                btn.disabled = false;
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }
        }

        // ========== END PHASE 8.3 ==========

        // Apply settings on page load
        document.addEventListener('DOMContentLoaded', function () {
            applySettings();
            fetchAssets();
            initializeScheduler();
            initializeStatisticsFilter();
        });

        // ----- Custom instant tooltip behavior -----
        (function () {
            const tip = document.createElement('div');
            tip.className = 'custom-tooltip';
            document.body.appendChild(tip);

            function showFor(el) {
                const text = el.dataset.tooltip || '';
                if (!text) return;
                tip.textContent = text;
                const r = el.getBoundingClientRect();
                const left = Math.round(r.left + window.scrollX);
                const top = Math.round(r.bottom + 6 + window.scrollY);
                tip.style.left = left + 'px';
                tip.style.top = top + 'px';
                tip.classList.add('visible');
            }

            function hide() {
                tip.classList.remove('visible');
            }

            // Show immediately on pointerenter, hide on pointerleave
            document.addEventListener('pointerenter', function (e) {
                const el = e.target.closest('[data-tooltip]');
                if (!el) return;
                showFor(el);
            }, true);

            document.addEventListener('pointerleave', function (e) {
                const el = e.target.closest('[data-tooltip]');
                if (!el) return;
                hide();
            }, true);

            // Reposition if the pointer moves inside the element
            document.addEventListener('pointermove', function (e) {
                const el = e.target.closest('[data-tooltip]');
                if (!el) return;
                const r = el.getBoundingClientRect();
                tip.style.left = Math.round(r.left + window.scrollX) + 'px';
                tip.style.top = Math.round(r.bottom + 6 + window.scrollY) + 'px';
            }, true);
        })();

    </script>
</body>

</html>