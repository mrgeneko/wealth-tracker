<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wealth Tracker Dashboard</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.5/awesomplete.min.css">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.5/awesomplete.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #121212;
            color: #e0e0e0;
        }

        h1,
        h2 {
            color: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Grid Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: #1e1e1e;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        th,
        td {
            padding: 10px;
            border: 1px solid #333;
            text-align: right;
            color: #e0e0e0;
        }

        th {
            background-color: #2d2d2d;
            font-weight: bold;
            text-align: center;
            color: #ffffff;
        }

        td:first-child,
        th:first-child {
            text-align: left;
        }

        /* Buttons */
        .btn {
            padding: 8px 12px;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn-primary {
            background-color: #0d6efd;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0b5ed7;
        }

        .btn-danger {
            background-color: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background-color: #bb2d3b;
        }

        /* Section Headers */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            margin-bottom: 10px;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .modal-content {
            background-color: #2d2d2d;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #444;
            width: 400px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: white;
        }

        .form-group {
            margin-bottom: 15px;
        }

        /* Prev-close small info icon (tooltip) */
        .prev-close-info {
            font-size: 0.75em;
            margin-left: 6px;
            color: #bbb;
            cursor: help;
            vertical-align: middle;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #e0e0e0;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #333;
            color: #fff;
        }

        /* Awesomplete Autocomplete Styles (Dark Theme) */
        .awesomplete>ul {
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-height: 350px;
            overflow-y: auto;
        }

        .awesomplete>ul>li {
            color: #e0e0e0;
            padding: 10px 12px;
            border-bottom: 1px solid #444;
        }

        .awesomplete>ul>li:last-child {
            border-bottom: none;
        }

        .awesomplete>ul>li:hover {
            background: #3d3d3d;
            color: #fff;
        }

        .awesomplete>ul>li[aria-selected="true"] {
            background: #0d6efd;
            color: #fff;
        }

        .awesomplete>ul>li[aria-selected="true"] .ticker-exchange {
            background: rgba(255, 255, 255, 0.3);
        }

        .awesomplete mark {
            background: #0d6efd;
            color: #fff;
        }

        /* Ticker item styling */
        .ticker-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .ticker-main {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ticker-symbol {
            font-weight: bold;
            font-size: 1.1em;
        }

        .ticker-exchange {
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .ticker-exchange.nasdaq {
            background: #0d6efd;
            color: #fff;
        }

        .ticker-exchange.nyse {
            background: #198754;
            color: #fff;
        }

        .ticker-exchange.nyse-mkt {
            background: #20c997;
            color: #000;
        }

        .ticker-exchange.nyse-arca {
            background: #6f42c1;
            color: #fff;
        }

        .ticker-exchange.bats {
            background: #fd7e14;
            color: #000;
        }

        .ticker-exchange.iex {
            background: #6610f2;
            color: #fff;
        }

        .ticker-exchange.other {
            background: #6c757d;
            color: #fff;
        }

        .ticker-exchange.treasury {
            background: #dc3545;
            color: #fff;
        }

        .ticker-name {
            font-size: 0.85em;
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 350px;
        }

        /* Clickable Cells */
        .clickable-cell {
            cursor: pointer;
            color: #6ea8fe;
            text-decoration: none;
            display: block;
            width: 100%;
            height: 100%;
        }

        .clickable-cell:hover {
            text-decoration: underline;
            background-color: #2c3e50;
        }

        .edit-icon {
            font-size: 0.8em;
            margin-left: 5px;
            color: #888;
            visibility: hidden;
        }

        .clickable-cell:hover .edit-icon {
            visibility: visible;
        }

        .row-total {
            font-weight: bold;
            background-color: #252525;
        }

        .total-row td {
            font-weight: bold;
            background-color: #333;
            border-top: 2px solid #555;
        }

        .positive {
            color: #4caf50;
        }

        .negative {
            color: #f44336;
        }

        /* Tabs */
        .tab {
            overflow: hidden;
            border-bottom: 1px solid #444;
            margin-bottom: 20px;
        }

        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            font-size: 17px;
            color: #aaa;
        }

        .tab button:hover {
            background-color: #333;
            color: white;
        }

        .tab button.active {
            background-color: #2d2d2d;
            color: white;
            border-bottom: 2px solid #0d6efd;
        }

        .tab-content {
            display: none;
            animation: fadeEffect 1s;
        }

        @keyframes fadeEffect {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Sortable Headers */
        .sortable-header {
            cursor: pointer;
            user-select: none;
        }

        .sortable-header:hover {
            background-color: #3d3d3d;
        }

        .sort-indicator {
            margin-left: 5px;
            font-size: 0.8em;
            color: #888;
        }

        .sort-indicator.active {
            color: #0d6efd;
        }

        /* Log Table Overrides */
        #log-table th:first-child,
        #log-table td:first-child {
            position: static !important;
            background-color: transparent !important;
            z-index: auto !important;
        }

        /* Icon Button */
        .icon-btn {
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            margin-left: 10px;
            color: #0d6efd;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 36px;
            width: 36px;
            border-radius: 50%;
            transition: background-color 0.3s;
        }

        .icon-btn:hover {
            background-color: rgba(13, 110, 253, 0.1);
        }

        .plus-icon {
            font-weight: bold;
            line-height: 1;
            display: inline-block;
            transition: transform 0.3s;
        }

        .icon-btn:hover .plus-icon {
            transform: scale(1.2);
        }

        /* Settings Button */
        .settings-btn {
            position: absolute;
            top: 0;
            right: 0;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: #0d6efd;
            font-size: 1.5em;
            border-radius: 50%;
            transition: background-color 0.3s, transform 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }

        .settings-btn:hover {
            background-color: rgba(13, 110, 253, 0.1);
            transform: scale(1.1);
        }

        .gear-icon {
            font-size: 1.2em;
            line-height: 1;
        }

        /* Settings Modal Styles */
        .settings-content {
            max-height: 60vh;
            overflow-y: auto;
        }

        .settings-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .settings-section h3 {
            margin: 0 0 15px 0;
            color: #ffffff;
            font-size: 1.1em;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 0;
        }

        .setting-item label {
            flex: 1;
            color: #e0e0e0;
            font-weight: normal;
        }

        .setting-item input[type="checkbox"] {
            margin-left: 10px;
        }

        .setting-item select {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 6px 8px;
            min-width: 120px;
        }

        /* Settings Dropdown */
        .settings-dropdown {
            display: none;
            position: absolute;
            top: 50px;
            right: 0;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 120px;
            overflow: hidden;
        }

        .dropdown-item {
            padding: 12px 16px;
            color: #e0e0e0;
            cursor: pointer;
            transition: background-color 0.3s;
            border-bottom: 1px solid #444;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background-color: #3d3d3d;
            color: #ffffff;
        }
    </style>
</head>

<body>
    <div class="container">
        <div style="position: relative;">
            <h1>Wealth Tracker Dashboard</h1>
            <div id="no-assets-warning" style="display:none; color: #ffb74d; margin-top: 8px;">No accounts data
                available — check server/API connection.</div>
            <button id="settingsBtn" class="settings-btn" title="Menu" onclick="toggleSettingsDropdown()">
                <span class="gear-icon">⚙️</span>
            </button>
            <div id="settingsDropdown" class="settings-dropdown">
                <div class="dropdown-item" onclick="showLogs()">Logs</div>
                <div class="dropdown-item" onclick="openSettingsModal()">Settings</div>
            </div>
        </div>
        <div id="last-updated" style="color: #aaa; font-size: 0.9em; margin-bottom: 20px;"></div>

        <div class="tab">
            <button class="tablinks active" onclick="openTab(event, 'Accounts')">Accounts</button>
            <button class="tablinks" onclick="openTab(event, 'Historical')">Historical Values</button>
            <button class="tablinks" onclick="openTab(event, 'Projections')">Projections</button>
        </div>

        <div id="Accounts" class="tab-content" style="display: block;">
            <!-- Investment Accounts -->
            <div class="section-header">
                <h2 style="display: flex; align-items: center; gap: 10px;">
                    <span>Investment Accounts</span>
                    <button class="icon-btn" title="Add Account" onclick="openAccountModal('investment')"
                        style="font-size: inherit; white-space: nowrap; margin-left: 32px;">
                        <span class="plus-icon" style="font-size: inherit; white-space: nowrap;">+ Account</span>
                    </button>
                    <span style="color: white; margin: 0 16px;">&nbsp;|&nbsp;</span>
                    <button class="icon-btn" title="Add Symbol" onclick="openAddSymbolModal()"
                        style="font-size: inherit; white-space: nowrap;">
                        <span class="plus-icon" style="font-size: inherit; white-space: nowrap;">+ Symbol</span>
                    </button>
                    <span style="color: white; margin: 0 16px;">&nbsp;|&nbsp;</span>
                    <button class="icon-btn" title="Expand Accounts" onclick="toggleAccountsCollapse()"
                        style="font-size: inherit; white-space: nowrap; margin-left: 32px;">
                        <span id="collapse-toggle" class="plus-icon"
                            style="font-size: inherit; white-space: nowrap;">Expand Accounts</span>
                    </button>
                </h2>
            </div>
            <table id="investment-grid">
                <thead></thead>
                <tbody></tbody>
            </table>

            <!-- Bank Accounts -->
            <div class="section-header">
                <h2 style="display: flex; align-items: center; gap: 10px;">
                    <span>Bank Accounts</span>
                    <button class="icon-btn" title="Add Account" onclick="openAccountModal('bank')">
                        <span class="plus-icon">+</span>
                    </button>
                </h2>
            </div>
            <table id="bank-grid">
                <thead></thead>
                <tbody></tbody>
            </table>

            <!-- Fixed Assets -->
            <div class="section-header">
                <h2 style="display: flex; align-items: center; gap: 10px;">
                    <span>Fixed Assets</span>
                    <button class="icon-btn" title="Add Asset" onclick="openAssetModal()">
                        <span class="plus-icon">+</span>
                    </button>
                </h2>
            </div>
            <table id="asset-grid">
                <thead></thead>
                <tbody></tbody>
            </table>

            <div id="total-net-worth"
                style="font-size: 1.5em; font-weight: bold; margin-top: 30px; margin-bottom: 20px;"></div>
        </div>

        <div id="Historical" class="tab-content">
            <h2>Historical Values</h2>
            <p>Historical data visualization coming soon.</p>
        </div>

        <div id="Projections" class="tab-content">
            <h2>Projections</h2>
            <p>Future wealth projections coming soon.</p>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="width: 350px;">
            <h2 id="confirmModalTitle">Confirm</h2>
            <p id="confirmModalMessage" style="margin-bottom: 20px;"></p>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button type="button" class="btn" style="background-color: #555; color: white;"
                    onclick="closeModal('confirmModal')">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmModalOk">Delete</button>
            </div>
        </div>
    </div>

    <!-- Account Modal -->
    <div id="accountModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('accountModal')">&times;</span>
            <h2 id="accountModalTitle">Add Account</h2>
            <form id="accountForm">
                <input type="hidden" id="accId">
                <input type="hidden" id="accCategory">
                <div class="form-group">
                    <label for="accName">Account Name</label>
                    <input type="text" id="accName" required>
                </div>
                <div class="form-group">
                    <label for="accType">Type</label>
                    <input type="text" id="accType" placeholder="e.g., 401k, Roth IRA, Checking">
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn btn-danger" id="btnDeleteAccount" style="display:none;"
                        onclick="deleteAccount()">Delete</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Position Modal -->
    <div id="positionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('positionModal')">&times;</span>
            <h2 id="positionModalTitle">Edit Position</h2>
            <form id="positionForm">
                <input type="hidden" id="posId">
                <input type="hidden" id="posAccountId">
                <input type="hidden" id="posSymbol">
                <input type="hidden" id="posType">
                <div class="form-group" id="posSymbolGroup">
                    <label for="posSymbol">Symbol</label>
                    <div id="posSymbolDisplay"
                        style="padding: 8px; border: 1px solid #555; border-radius: 4px; background-color: #555; color: #fff; width: 100%;">
                    </div>
                </div>
                <div class="form-group">
                    <div id="posTypeGroup">
                        <label for="posType">Type</label>
                        <div id="posTypeDisplay"
                            style="padding: 8px; border: 1px solid #555; border-radius: 4px; background-color: #555; color: #fff; width: 100%;">
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <div id="posAccountGroup">
                        <label for="posAccount">Account</label>
                        <div id="posAccountDisplay"
                            style="padding: 8px; border: 1px solid #555; border-radius: 4px; background-color: #555; color: #fff; width: 100%;">
                        </div>
                    </div>
                    <label for="posQuantity">Quantity</label>
                    <input type="number" step="any" id="posQuantity" required>
                    <small style="color: #aaa;">For Cash, enter the total value.</small>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn btn-danger" id="btnDeletePosition" style="display:none;"
                        onclick="deletePosition()">Delete</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Asset Modal -->
    <div id="assetModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('assetModal')">&times;</span>
            <h2 id="assetModalTitle">Add Asset</h2>
            <form id="assetForm">
                <input type="hidden" id="assetId">
                <div class="form-group">
                    <label for="assetName">Name</label>
                    <input type="text" id="assetName" required>
                </div>
                <div class="form-group">
                    <label for="assetType">Type</label>
                    <select id="assetType">
                        <option value="real_estate">Real Estate</option>
                        <option value="vehicle">Vehicle</option>
                        <option value="other">Other</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="assetValue">Value</label>
                    <input type="number" step="any" id="assetValue" required>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn btn-danger" id="btnDeleteAsset" style="display:none;"
                        onclick="deleteAsset()">Delete</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('settingsModal')">&times;</span>
            <h2>Settings</h2>
            <div class="settings-content">
                <div class="settings-section">
                    <h3>Dashboard Preferences</h3>
                    <div class="setting-item">
                        <label for="autoRefresh">Auto refresh account and positions</label>
                        <input type="checkbox" id="autoRefresh" checked>
                    </div>
                    <div class="setting-item">
                        <label for="refreshInterval">Refresh interval (seconds)</label>
                        <select id="refreshInterval">
                            <option value="30">30 seconds</option>
                            <option value="60" selected>1 minute</option>
                            <option value="300">5 minutes</option>
                            <option value="600">10 minutes</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="theme">Theme</label>
                        <select id="theme">
                            <option value="dark" selected>Dark</option>
                            <option value="light">Light</option>
                        </select>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>System</h3>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn btn-primary" onclick="exportData()">Export Data</button>
                        <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">Import
                            Data</button>
                        <input type="file" id="importFile" accept=".json" style="display: none;"
                            onchange="importData(this)">
                    </div>
                    <button class="btn btn-danger" onclick="clearCache()">Clear Cache</button>
                </div>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
                <button type="button" class="btn" style="background-color: #555; color: white;"
                    onclick="closeModal('settingsModal')">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Logs Modal -->
    <div id="logsModal" class="modal">
        <div class="modal-content logs-modal-content">
            <span class="close" onclick="closeModal('logsModal')">&times;</span>
            <h2>System Logs</h2>
            <div id="logs-container" style="display: flex; height: 600px; border: 1px solid #444;">
                <div id="log-list-pane"
                    style="width: 27.5%; min-width: 150px; overflow-y: auto; overflow-x: auto; background: #1e1e1e;">
                    <table id="log-table" style="width: 100%; font-size: 0.8em; table-layout: fixed;">
                        <thead>
                            <tr>
                                <th id="col-file" style="text-align: left; padding: 5px; position: relative;">File</th>
                                <th id="col-time"
                                    style="text-align: left; padding: 5px; width: 132px; white-space: nowrap;">Time</th>
                                <th id="col-size"
                                    style="text-align: right; padding: 5px; width: 70px; white-space: nowrap;">Size</th>
                            </tr>
                        </thead>
                        <tbody id="log-list"></tbody>
                    </table>
                </div>
                <div id="pane-resizer"
                    style="width: 5px; cursor: col-resize; background-color: #444; user-select: none; z-index: 10;">
                </div>
                <div id="log-viewer-pane"
                    style="flex: 1; min-width: 150px; overflow-y: auto; padding: 10px; background: #121212; font-family: monospace; white-space: pre-wrap;">
                    Select a log file to view...
                </div>
            </div>
        </div>
    </div>

    <!-- Add Symbol Modal -->
    <div id="addSymbolModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addSymbolModal')">&times;</span>
            <h2>Add Symbol</h2>
            <form id="addSymbolForm">
                <div class="form-group">
                    <label for="newSymbol">Symbol</label>
                    <input type="text" id="newSymbol" required maxlength="50" style="text-transform:uppercase;"
                        class="awesomplete" autocomplete="off">
                </div>
                <div class="form-group">
                    <label for="newSymbolType">Type</label>
                    <select id="newSymbolType">
                        <option value="stock">Stock</option>
                        <option value="etf">ETF</option>
                        <option value="bond">Bond</option>
                        <option value="crypto">Crypto</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="newSymbolAccount">Account</label>
                    <select id="newSymbolAccount" required></select>
                </div>
                <div class="form-group">
                    <label for="newSymbolQuantity">Quantity</label>
                    <input type="number" id="newSymbolQuantity" min="0" step="any" value="0" required>
                </div>
                <div id="addSymbolError" style="color: #f44336; margin-bottom: 10px; display: none;"></div>
                <div style="display: flex; justify-content: flex-end; gap: 10px;">
                    <button type="button" class="btn" style="background-color: #555; color: white;"
                        onclick="closeModal('addSymbolModal')">Cancel</button>
                    <button type="submit" class="btn btn-primary">Add</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Ticker autocomplete setup
        let symbolAutocomplete = null;
        let autocompleteTimeout = null;

        function openAddSymbolModal() {
            document.getElementById('addSymbolError').style.display = 'none';
            document.getElementById('addSymbolForm').reset();
            // Populate account dropdown
            const accountSelect = document.getElementById('newSymbolAccount');
            accountSelect.innerHTML = '';
            if (lastAssetsData && lastAssetsData.accounts) {
                const investmentAccounts = lastAssetsData.accounts.filter(a => a.category === 'investment' || !a.category);
                investmentAccounts.forEach(acc => {
                    const opt = document.createElement('option');
                    opt.value = acc.id;
                    opt.textContent = acc.name + (acc.type ? ` (${acc.type})` : '');
                    accountSelect.appendChild(opt);
                });
            }

            // Initialize Awesomplete
            const input = document.getElementById('newSymbol');
            if (!symbolAutocomplete) {
                symbolAutocomplete = new Awesomplete(input, {
                    minChars: 1,
                    maxItems: 15,
                    autoFirst: true,
                    filter: () => true, // We filter on server
                    sort: false, // We sort on server
                    data: function (item) {
                        return { label: item.label, value: item.value };
                    },
                    item: function (item) {
                        const li = document.createElement('li');
                        li.innerHTML = `
                                    <div class="ticker-item">
                                        <div class="ticker-main">
                                            <span class="ticker-symbol">${item.value}</span>
                                            <span class="ticker-exchange ${item.exchangeClass}">${item.exchange}</span>
                                        </div>
                                        <div class="ticker-name">${item.name}</div>
                                    </div>
                                `;
                        return li;
                    }
                });

                // Dynamic fetch listener
                input.addEventListener('input', function () {
                    const query = this.value;
                    if (query.length < 1) return;

                    if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
                    autocompleteTimeout = setTimeout(async () => {
                        try {
                            const res = await fetch(`/api/metadata/autocomplete?q=${encodeURIComponent(query)}`);
                            const data = await res.json();

                            const list = data.results.map(t => ({
                                label: t.symbol,
                                value: t.symbol,
                                name: t.name,
                                exchange: t.exchange,
                                exchangeClass: (t.exchange || '').toLowerCase().replace(/\\s+/g, '-')
                            }));

                            symbolAutocomplete.list = list;
                        } catch (err) {
                            console.error('Autocomplete error:', err);
                        }
                    }, 300); // 300ms debounce
                });
            }

            document.getElementById('addSymbolModal').style.display = 'block';
        }

        document.getElementById('addSymbolForm').onsubmit = async function (e) {
            e.preventDefault();
            const symbol = document.getElementById('newSymbol').value.trim().toUpperCase();
            const type = document.getElementById('newSymbolType').value;
            const accountId = document.getElementById('newSymbolAccount').value;
            const quantity = parseFloat(document.getElementById('newSymbolQuantity').value);
            if (!symbol || !accountId || isNaN(quantity)) return;
            // Check if symbol already exists in this account
            let symbolExists = false;
            if (lastAssetsData && lastAssetsData.accounts) {
                const acc = lastAssetsData.accounts.find(a => String(a.id) === String(accountId));
                if (acc) {
                    acc.holdings.stocks.forEach(pos => { if (pos.symbol.toUpperCase() === symbol) symbolExists = true; });
                    acc.holdings.bonds.forEach(pos => { if (pos.symbol.toUpperCase() === symbol) symbolExists = true; });
                }
            }
            if (symbolExists) {
                document.getElementById('addSymbolError').innerText = 'Symbol already exists in this account.';
                document.getElementById('addSymbolError').style.display = 'block';
                return;
            }
            // Add symbol to selected account with specified quantity
            try {
                let currency = 'USD';
                if (lastAssetsData && lastAssetsData.accounts) {
                    const acc = lastAssetsData.accounts.find(a => String(a.id) === String(accountId));
                    if (acc && acc.currency) currency = acc.currency;
                }
                // Prefetch metadata for the new symbol
                try {
                    await fetch('/api/metadata/prefetch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ symbol })
                    });
                } catch (e) {
                    console.warn('Metadata prefetch failed:', e);
                }

                await fetch('/api/positions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        account_id: accountId,
                        symbol,
                        type,
                        quantity,
                        currency
                    })
                });
                closeModal('addSymbolModal');
                fetchAssets();
            } catch (err) {
                document.getElementById('addSymbolError').innerText = 'Error adding symbol.';
                document.getElementById('addSymbolError').style.display = 'block';
            }
        };
        const socket = io();
        let currentPrices = {};
        let lastAssetsData = null;
        let previousPrices = {}; // Store previous prices for comparison
        let previousValues = {}; // Store previous values for comparison

        // --- Sorting State ---
        let investmentGridSort = { column: 'symbol', direction: 'asc' };
        let accountOrder = [];

        // --- Accounts Collapse State ---
        let accountsCollapsed = true; // Start with accounts collapsed by default

        // --- Socket.IO Listeners ---
        socket.on('price_update', (data) => {
            console.log('Price update received');
            const oldPrices = { ...currentPrices };
            currentPrices = data;

            if (lastAssetsData) {
                // Use in-place update for smoother animations
                updateInvestmentGridInPlace('investment-grid', lastAssetsData.accounts.filter(a => a.category === 'investment' || !a.category), oldPrices);
            }
        });

        socket.on('assets_update', (data) => {
            console.log('Assets update received');
            fetchAssets();
        });

        // --- Data Fetching ---
        async function fetchAssets() {
            console.log('Fetching assets...');
            try {
                const response = await fetch('/api/assets');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('Assets received:', data);
                lastAssetsData = data;
                renderAll();
                const warn = document.getElementById('no-assets-warning');
                if (warn) warn.style.display = 'none';
            } catch (error) {
                console.error('Error fetching assets:', error);
                const warn = document.getElementById('no-assets-warning');
                if (warn) warn.style.display = 'block';
            }
        }

        // --- Rendering ---
        function renderAll() {
            if (!lastAssetsData) return;

            // Filter accounts
            let investmentAccounts = lastAssetsData.accounts.filter(a => a.category === 'investment' || !a.category);

            // Initialize or update accountOrder
            if (accountOrder.length === 0) {
                accountOrder = investmentAccounts.map(a => a.id);
            } else {
                const currentIds = new Set(investmentAccounts.map(a => a.id));
                accountOrder = accountOrder.filter(id => currentIds.has(id));
                investmentAccounts.forEach(a => {
                    if (!accountOrder.includes(a.id)) accountOrder.push(a.id);
                });
            }

            // Sort investmentAccounts based on accountOrder
            investmentAccounts.sort((a, b) => {
                const idxA = accountOrder.findIndex(id => String(id) === String(a.id));
                const idxB = accountOrder.findIndex(id => String(id) === String(b.id));
                return idxA - idxB;
            });

            const bankAccounts = lastAssetsData.accounts.filter(a => a.category === 'bank');

            // Combine fixed assets
            const fixedAssets = [
                ...(lastAssetsData.real_estate || []).map(a => ({ ...a, type: 'real_estate' })),
                ...(lastAssetsData.vehicles || []).map(a => ({ ...a, type: 'vehicle' }))
            ];

            renderInvestmentGridWithFlashes('investment-grid', investmentAccounts, {});
            renderBankGrid('bank-grid', bankAccounts);
            renderAssetGrid('asset-grid', fixedAssets);

            // Calculate Net Worth
            let netWorth = 0;
            // Add fixed assets
            fixedAssets.forEach(a => netWorth += a.value);
            // Add accounts (calculated in render functions, but we can re-calc here or grab from DOM)
            // Let's re-calc for accuracy
            lastAssetsData.accounts.forEach(acc => {
                if (acc.holdings.cash) netWorth += acc.holdings.cash.value;
                acc.holdings.stocks.forEach(p => {
                    const price = getPriceDataForSymbol(p.symbol)?.price || 0;
                    netWorth += p.quantity * price;
                });
                acc.holdings.bonds.forEach(p => {
                    const price = getPriceDataForSymbol(p.symbol)?.price || 0;
                    // Bonds use price/100
                    netWorth += p.quantity * (price / 100.0);
                });
            });

            document.getElementById('total-net-worth').innerText = `Total Net Worth: $${formatNumber(netWorth)}`;
            document.getElementById('last-updated').innerText = `Last Updated: ${new Date().toLocaleString()}`;
        }

        // In-place update function for smooth animations
        function updateInvestmentGridInPlace(tableId, accounts, oldPrices) {
            if (!accounts || accounts.length === 0) return;

            // Collect all unique symbols
            const allSymbols = new Set();
            accounts.forEach(acc => {
                acc.holdings.stocks.forEach(pos => allSymbols.add(pos.symbol));
                acc.holdings.bonds.forEach(pos => allSymbols.add(pos.symbol));
            });

            let grandTotalValueChange = 0;

            allSymbols.forEach(sym => {
                const normalized = normalizeTicker(sym);
                const oldPriceData = oldPrices[sym] || oldPrices[normalized];
                const newPriceData = getPriceDataForSymbol(sym);

                if (!newPriceData) return;

                let price = newPriceData.price;
                // Prefer a valid previous_close_price from the incoming data.
                // RATIONALE: Some scrapers (or intermittent updates) may not provide
                // `previous_close_price` on every update, or might send an empty
                // string / zero. If we blindly set prev-close to that, the dashboard
                // will display 0 and compute changes from an incorrect base.
                // To protect the UI value we:
                // 1) Accept an incoming previous_close_price only if it's a valid
                //    positive number (parseFloat > 0).
                // 2) If the incoming value is missing/invalid, fall back to the
                //    previously-known value (from oldPriceData) if available.
                // This mirrors the server-side cache behavior and prevents noisy
                // scrapers from erasing a valid Prev Close.
                let prevClose = 0;
                if (newPriceData.previous_close_price !== undefined && newPriceData.previous_close_price !== null && newPriceData.previous_close_price !== '') {
                    const parsedPrev = parseFloat(newPriceData.previous_close_price);
                    if (!isNaN(parsedPrev) && parsedPrev > 0) {
                        prevClose = parsedPrev;
                    } else if (oldPriceData && oldPriceData.previous_close_price) {
                        // incoming prev close is present but invalid (e.g. 0 or NaN) — fall back to old
                        prevClose = parseFloat(oldPriceData.previous_close_price) || 0;
                    }
                } else if (oldPriceData && oldPriceData.previous_close_price) {
                    // incoming prev close missing — reuse the old value
                    prevClose = parseFloat(oldPriceData.previous_close_price) || 0;
                }
                let changeVal = price - prevClose;
                let changePct = prevClose ? ((price - prevClose) / prevClose * 100).toFixed(3) + '%' : '0%';
                let timeStr = '-';
                let sourceStr = newPriceData.source || '-';

                if (newPriceData.time) {
                    const d = new Date(newPriceData.time);
                    if (!isNaN(d.getTime())) {
                        // Format as 'M/D HH:mm:ss'
                        const month = d.getMonth() + 1;
                        const day = d.getDate();
                        const hours = d.getHours().toString().padStart(2, '0');
                        const minutes = d.getMinutes().toString().padStart(2, '0');
                        const seconds = d.getSeconds().toString().padStart(2, '0');
                        timeStr = `${month}/${day} ${hours}:${minutes}:${seconds}`;
                    } else {
                        timeStr = newPriceData.time;
                    }
                }

                let color = '#e0e0e0';
                if (changeVal > 0) color = '#4caf50';
                if (changeVal < 0) color = '#f44336';

                let changePctNum = 0;
                if (changePct && changePct !== '0%') {
                    changePctNum = parseFloat(changePct.replace('%', '').replace(',', '')) || 0;
                }

                // Calculate totals for this symbol
                let symTotalValue = 0;
                let symTotalValueChange = 0;

                accounts.forEach(acc => {
                    let pos = acc.holdings.stocks.find(p => p.symbol === sym);
                    let isBond = false;
                    if (!pos) {
                        pos = acc.holdings.bonds.find(p => p.symbol === sym);
                        if (pos) isBond = true;
                    }

                    if (pos) {
                        let calcPrice = price;
                        let calcChange = changeVal;
                        if (isBond) {
                            calcPrice = price / 100.0;
                            calcChange = changeVal / 100.0;
                        }

                        const value = pos.quantity * calcPrice;
                        symTotalValue += value;
                        symTotalValueChange += pos.quantity * calcChange;

                        // Update account cell in-place
                        const cellId = `cell-${sym}-${acc.id}`;
                        const cell = document.getElementById(cellId);
                        if (cell) {
                            const oldValue = previousValues[cellId] || 0;
                            if (oldValue !== 0 && value !== oldValue) {
                                applyFlash(cell, value > oldValue);
                            }
                            previousValues[cellId] = value;
                            // Update cell content
                            const clickableSpan = cell.querySelector('.clickable-cell');
                            if (clickableSpan) {
                                clickableSpan.innerHTML = `${formatNumber(value)}<br><small>${pos.quantity.toFixed(0)}</small>`;
                            }
                        }
                    }
                });

                grandTotalValueChange += symTotalValueChange;

                // Update price cell
                const priceCell = document.getElementById(`price-${sym}`);
                if (priceCell) {
                    if (oldPriceData && oldPriceData.price !== 0 && price !== oldPriceData.price) {
                        applyFlash(priceCell, price > oldPriceData.price);
                    }
                    priceCell.textContent = formatNumber(price);
                }

                // Update prevClose cell
                const prevCloseCell = document.getElementById(`prevClose-${sym}`);
                if (prevCloseCell) {
                    // Only update the cell if the incoming data contains a valid prev close.
                    if (newPriceData.previous_close_price !== undefined && newPriceData.previous_close_price !== null && newPriceData.previous_close_price !== '') {
                        const parsedPrev = parseFloat(newPriceData.previous_close_price);
                        if (!isNaN(parsedPrev) && parsedPrev > 0) {
                            // Build tooltip from metadata if available
                            const sourceMeta = newPriceData.prev_close_source || newPriceData.previous_close_source || newPriceData.source || (oldPriceData && oldPriceData.prev_close_source) || '';
                            const timeMeta = newPriceData.prev_close_time || newPriceData.previous_close_time || newPriceData.capture_time || (oldPriceData && oldPriceData.prev_close_time) || '';
                            let tooltip = '';
                            if (sourceMeta) tooltip += `Source: ${sourceMeta}`;
                            if (timeMeta) tooltip += (tooltip ? '\n' : '') + `Time: ${timeMeta}`;
                            if (tooltip) {
                                prevCloseCell.innerHTML = `${formatNumber(parsedPrev)} <span class="prev-close-info" title="${escapeHtml(tooltip)}">ℹ</span>`;
                            } else {
                                prevCloseCell.textContent = formatNumber(parsedPrev);
                            }
                        } else {
                            // incoming invalid value: do not overwrite existing cell
                        }
                    } else {
                        // incoming value is missing: do not overwrite existing cell
                        if (oldPriceData && oldPriceData.previous_close_price) {
                            console.warn(`[PrevClose] Skipping update for ${sym}, incoming prev close missing — preserving previous value ${oldPriceData.previous_close_price}`);
                        }
                    }
                }

                // Update change cell
                const changeCell = document.getElementById(`change-${sym}`);
                if (changeCell) {
                    if (oldPriceData && oldPriceData.change !== undefined && changeVal !== oldPriceData.change) {
                        applyFlash(changeCell, changeVal > oldPriceData.change);
                    }
                    changeCell.textContent = formatNumber(changeVal);
                    changeCell.style.color = color;
                }

                // Update change% cell
                const changePctCell = document.getElementById(`changePct-${sym}`);
                if (changePctCell) {
                    if (oldPriceData) {
                        const oldChangePctNum = parseFloat((oldPriceData.change_percent || '0%').replace('%', '').replace(',', '')) || 0;
                        if (oldChangePctNum !== 0 && changePctNum !== oldChangePctNum) {
                            applyFlash(changePctCell, changePctNum > oldChangePctNum);
                        }
                    }
                    changePctCell.textContent = `${changePctNum.toFixed(3)}%`;
                    changePctCell.style.color = color;
                }

                // Update time cell (text flash)
                const timeCell = document.getElementById(`time-${sym}`);
                if (timeCell) {
                    if (oldPriceData && oldPriceData.time !== newPriceData.time) {
                        applyTextFlash(timeCell);
                    }
                    timeCell.textContent = timeStr;
                }

                // Update source cell (text flash)
                const sourceCell = document.getElementById(`source-${sym}`);
                if (sourceCell) {
                    if (oldPriceData && oldPriceData.source !== newPriceData.source) {
                        applyTextFlash(sourceCell);
                    }
                    sourceCell.textContent = sourceStr;
                }

                // Update value change cell
                const valueChangeCell = document.getElementById(`valueChange-${sym}`);
                if (valueChangeCell) {
                    const oldValueChange = previousValues[`valueChange-${sym}`] || 0;
                    if (oldValueChange !== 0 && symTotalValueChange !== oldValueChange) {
                        applyFlash(valueChangeCell, symTotalValueChange > oldValueChange);
                    }
                    previousValues[`valueChange-${sym}`] = symTotalValueChange;
                    valueChangeCell.textContent = formatNumber(symTotalValueChange);
                    valueChangeCell.style.color = color;
                }

                // Update total cell
                const totalCell = document.getElementById(`total-${sym}`);
                if (totalCell) {
                    const oldTotal = previousValues[`total-${sym}`] || 0;
                    if (oldTotal !== 0 && symTotalValue !== oldTotal) {
                        applyFlash(totalCell, symTotalValue > oldTotal);
                    }
                    previousValues[`total-${sym}`] = symTotalValue;
                    totalCell.textContent = formatNumber(symTotalValue, 0);
                }
            });

            // Calculate grand total for all accounts and update account totals
            let grandTotal = 0;
            accounts.forEach(acc => {
                let accTotal = 0;
                if (acc.holdings.cash) accTotal += acc.holdings.cash.value;
                acc.holdings.stocks.forEach(p => {
                    const priceData = getPriceDataForSymbol(p.symbol);
                    let price = priceData?.price || 0;
                    accTotal += p.quantity * price;
                });
                acc.holdings.bonds.forEach(p => {
                    const priceData = getPriceDataForSymbol(p.symbol);
                    let price = priceData?.price || 0;
                    // Bonds use price/100
                    accTotal += p.quantity * (price / 100.0);
                });
                grandTotal += accTotal;

                // Update account total cell in Total row
                const accTotalCell = document.getElementById(`total-row-acc-${acc.id}`);
                if (accTotalCell) {
                    accTotalCell.textContent = formatNumber(accTotal);
                }
            });

            // Update Total row Value Change cell
            const totalRowValueChangeCell = document.getElementById('total-row-value-change');
            if (totalRowValueChangeCell) {
                let totalChangeColor = '#e0e0e0';
                if (grandTotalValueChange > 0) totalChangeColor = '#4caf50';
                if (grandTotalValueChange < 0) totalChangeColor = '#f44336';
                totalRowValueChangeCell.textContent = formatNumber(grandTotalValueChange);
                totalRowValueChangeCell.style.color = totalChangeColor;
            }

            // Update Total row Grand Total cell
            const totalRowGrandTotalCell = document.getElementById('total-row-grand-total');
            if (totalRowGrandTotalCell) {
                totalRowGrandTotalCell.textContent = formatNumber(grandTotal, 0);
            }

            // Update Total Net Worth (includes fixed assets and bank accounts)
            let netWorth = grandTotal;
            // Add fixed assets
            if (lastAssetsData) {
                (lastAssetsData.real_estate || []).forEach(a => netWorth += a.value);
                (lastAssetsData.vehicles || []).forEach(a => netWorth += a.value);
                // Add bank accounts
                lastAssetsData.accounts.filter(a => a.category === 'bank').forEach(acc => {
                    if (acc.holdings.cash) netWorth += acc.holdings.cash.value;
                });
            }
            document.getElementById('total-net-worth').innerText = `Total Net Worth: $${formatNumber(netWorth)}`;

            // Update last updated timestamp
            document.getElementById('last-updated').innerText = `Last Updated: ${new Date().toLocaleString()}`;
        }

        // Helper function to apply background flash animation
        function applyFlash(element, isPositive) {
            element.classList.remove('flash-positive', 'flash-negative');
            // Force reflow to restart animation
            void element.offsetWidth;
            element.classList.add(isPositive ? 'flash-positive' : 'flash-negative');
        }

        // Helper function to apply text flash animation
        function applyTextFlash(element) {
            element.classList.remove('flash-text');
            // Force reflow to restart animation
            void element.offsetWidth;
            element.classList.add('flash-text');
        }

        function toggleAccountsCollapse() {
            accountsCollapsed = !accountsCollapsed;
            const toggleButton = document.getElementById('collapse-toggle');
            if (accountsCollapsed) {
                toggleButton.innerHTML = 'Expand Accounts';
                toggleButton.title = 'Expand Accounts';
            } else {
                toggleButton.innerHTML = 'Collapse Accounts';
                toggleButton.title = 'Collapse Accounts';
            }
            // Re-render the investment grid with the new collapsed state
            if (lastAssetsData) {
                const investmentAccounts = lastAssetsData.accounts.filter(a => a.category === 'investment' || !a.category);
                renderInvestmentGridWithFlashes('investment-grid', investmentAccounts, {});
            }
        }

        function renderInvestmentGrid(tableId, accounts) {
            renderInvestmentGridWithFlashes(tableId, accounts, {});
        }

        function renderInvestmentGridWithFlashes(tableId, accounts, oldPrices) {
            const gridTable = document.getElementById(tableId);
            const thead = gridTable.querySelector('thead');
            const tbody = gridTable.querySelector('tbody');

            if (!accounts || accounts.length === 0) {
                thead.innerHTML = '';
                tbody.innerHTML = '<tr><td>No accounts found. Add one to get started.</td></tr>';
                return;
            }

            // Collect all unique symbols
            const allSymbols = new Set();
            accounts.forEach(acc => {
                acc.holdings.stocks.forEach(pos => allSymbols.add(pos.symbol));
                acc.holdings.bonds.forEach(pos => allSymbols.add(pos.symbol));
            });
            const sortedSymbols = Array.from(allSymbols).sort();

            // Header with sortable columns
            const sortIndicator = (col) => {
                if (investmentGridSort.column === col) {
                    return `<span class="sort-indicator active">${investmentGridSort.direction === 'asc' ? '▲' : '▼'}</span>`;
                }
                return '<span class="sort-indicator">⇅</span>';
            };
            let headerHtml = `<tr><th class="sortable-header" style="text-align: left" onclick="sortInvestmentGrid('symbol')">Symbol${sortIndicator('symbol')}</th>`;
            headerHtml += `<th class="sortable-header" style="text-align: left" onclick="sortInvestmentGrid('name')">Name${sortIndicator('name')}</th>`;
            headerHtml += `<th class="sortable-header" style="text-align: left" onclick="sortInvestmentGrid('sector')">Sector${sortIndicator('sector')}</th>`;

            if (accountsCollapsed) {
                // When collapsed, show only a "Shares" column
                headerHtml += `<th style="text-align: center">Shares</th>`;
            } else {
                // When expanded, show all account columns
                accounts.forEach(acc => {
                    const accJson = escapeHtml(JSON.stringify(acc));
                    const accType = acc.type ? acc.type.toUpperCase() : '';
                    headerHtml += `<th style="text-align: center" draggable="true" ondragstart="dragStart(event, '${acc.id}')" ondragover="allowDrop(event)" ondrop="drop(event, '${acc.id}')"><span class="clickable-cell" onclick="openAccountModal(null, ${accJson})">${acc.name}<br><span class='account-type'>${accType}</span> <span class="edit-icon">✎</span></span></th>`;
                });
            }

            headerHtml += `<th>Prev Close</th><th>Price</th><th>P/E</th><th>Yield</th><th>Change</th><th class="sortable-header" onclick="sortInvestmentGrid('changePct')">Change %${sortIndicator('changePct')}</th><th>Time</th><th>Source</th><th class="sortable-header" onclick="sortInvestmentGrid('valueChange')">Value Change${sortIndicator('valueChange')}</th><th class="sortable-header" onclick="sortInvestmentGrid('total')">Total${sortIndicator('total')}</th></tr>`;
            thead.innerHTML = headerHtml;

            let bodyHtml = '';
            let grandTotalValueChange = 0;

            // Build row data for sorting
            const rowData = [];
            sortedSymbols.forEach(sym => {
                let rowInfo = { symbol: sym, changePct: 0, valueChange: 0, total: 0, name: '', sector: '' };
                let price = 0;
                let changePct = '0%';
                let changeVal = 0;
                let prevClose = 0;
                let timeStr = '-';
                let sourceStr = '-';
                let color = '#e0e0e0';

                const normalized = normalizeTicker(sym);
                const newPriceData = getPriceDataForSymbol(sym);
                const oldPricesLookup = oldPrices[sym] || oldPrices[normalized];
                if (newPriceData) {
                    price = newPriceData.price;
                    // Prefer a valid previous_close_price from the currentPrices object.
                    // NOTE: When the dashboard performs a full render (e.g. page refresh)
                    // or is fed a fresh snapshot of `currentPrices`, some scrapers may
                    // still provide no previous_close_price for certain tickers. To
                    // maintain a consistent UX and avoid computing changes from a
                    // bogus zero base, we only accept incoming prev-close values
                    // that are valid positive numbers. When a current snapshot lacks
                    // a valid previous_close_price, we fall back to the previously
                    // known value (from oldPrices) — this mirrors server-side cache
                    // behavior and prevents accidental erasure of a valid Prev Close.
                    prevClose = 0;
                    if (newPriceData.previous_close_price !== undefined && newPriceData.previous_close_price !== null && newPriceData.previous_close_price !== '') {
                        const parsedPrev = parseFloat(newPriceData.previous_close_price);
                        if (!isNaN(parsedPrev) && parsedPrev > 0) {
                            prevClose = parsedPrev;
                        } else if (oldPricesLookup && oldPricesLookup.previous_close_price) {
                            // fallback to prev value if current data doesn't provide valid prev close
                            prevClose = parseFloat(oldPrices[sym].previous_close_price) || 0;
                            console.warn(`[PrevClose] Current data for ${sym} missing valid prev close — falling back to previous value ${prevClose}`);
                        }
                    } else if (oldPricesLookup && oldPricesLookup.previous_close_price) {
                        // Fall back to previously known value when current has none
                        prevClose = parseFloat(oldPrices[sym].previous_close_price) || 0;
                    }
                    changeVal = price - prevClose;
                    changePct = prevClose ? ((price - prevClose) / prevClose * 100).toFixed(3) + '%' : '0%';
                    console.log(`[PrevClose] ${sym}: price=${price}, prevClose=${prevClose}, changeVal=${changeVal}, changePct=${changePct}`);

                    if (newPriceData.time) {
                        const d = new Date(newPriceData.time);
                        if (!isNaN(d.getTime())) {
                            // Format as 'M/D HH:mm:ss'
                            const month = d.getMonth() + 1;
                            const day = d.getDate();
                            const hours = d.getHours().toString().padStart(2, '0');
                            const minutes = d.getMinutes().toString().padStart(2, '0');
                            const seconds = d.getSeconds().toString().padStart(2, '0');
                            timeStr = `${month}/${day} ${hours}:${minutes}:${seconds}`;
                        } else {
                            timeStr = newPriceData.time;
                        }
                    }

                    sourceStr = newPriceData.source || '-';
                    if (changeVal > 0) color = '#4caf50';
                    if (changeVal < 0) color = '#f44336';
                }

                // Metadata placeholders
                let metaName = '';
                let metaSector = '';
                let metaPE = '-';
                let metaYield = '-';

                // Find metadata from position (if any account has valid metadata)
                for (const acc of accounts) {
                    const stockPos = acc.holdings.stocks.find(p => p.symbol === sym);
                    if (stockPos) {
                        if (stockPos.short_name) metaName = stockPos.short_name;
                        if (stockPos.sector) metaSector = stockPos.sector;
                        if (stockPos.trailing_pe) metaPE = stockPos.trailing_pe.toFixed(2);
                        if (stockPos.dividend_yield) metaYield = (stockPos.dividend_yield * 100).toFixed(2) + '%';
                        if (metaName && metaSector) break; // Found enough info
                    }
                }

                // Store for sorting
                rowInfo.name = metaName;
                rowInfo.sector = metaSector;

                let rowHtml = `<tr><td style="text-align: left; font-weight: bold;">${sym}</td>`;
                rowHtml += `<td style="text-align: left; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(metaName)}">${metaName}</td>`;
                rowHtml += `<td style="text-align: left">${metaSector}</td>`;

                let symTotalValue = 0;
                let symTotalValueChange = 0;
                let symTotalShares = 0;

                accounts.forEach(acc => {
                    // Find position in stocks or bonds
                    let pos = acc.holdings.stocks.find(p => p.symbol === sym);
                    let isBond = false;
                    if (!pos) {
                        pos = acc.holdings.bonds.find(p => p.symbol === sym);
                        if (pos) isBond = true;
                    }

                    if (pos) {
                        let calcPrice = price;
                        let calcChange = changeVal;
                        if (isBond) {
                            calcPrice = price / 100.0;
                            calcChange = changeVal / 100.0;
                        }

                        const value = pos.quantity * calcPrice;
                        symTotalValue += value;
                        symTotalValueChange += pos.quantity * calcChange;
                        symTotalShares += pos.quantity;
                        const posType = isBond ? 'bond' : 'stock';
                        const posData = { id: pos.id, account_id: acc.id, symbol: pos.symbol, type: posType, quantity: pos.quantity };
                        const posJson = escapeHtml(JSON.stringify(posData));

                        // Check for value changes and apply flash animations
                        const cellId = `cell-${sym}-${acc.id}`;
                        let flashClass = '';

                        // Check if this cell value has changed
                        const oldValue = previousValues[cellId] || 0;
                        const newValue = value;
                        if (oldValue !== 0 && newValue !== oldValue) {
                            flashClass = newValue > oldValue ? 'flash-positive' : 'flash-negative';
                        }
                        previousValues[cellId] = newValue;

                        if (!accountsCollapsed) {
                            rowHtml += `<td id="${cellId}" class="${flashClass}"><span class="clickable-cell" onclick="openPositionModal(${posJson})">${formatNumber(value)}<br><small>${pos.quantity.toFixed(0)}</small></span></td>`;
                        }
                    } else {
                        if (!accountsCollapsed) {
                            const addPosData = { account_id: acc.id, account_name: acc.name, symbol: sym, type: 'stock', quantity: 0 };
                            const addPosJson = escapeHtml(JSON.stringify(addPosData));
                            rowHtml += `<td><span class="clickable-cell" style="color: #555; text-align: center;" onclick="openPositionModal(${addPosJson})">+</span></td>`;
                        }
                    }
                });

                // If collapsed, add single Shares column
                if (accountsCollapsed) {
                    rowHtml += `<td style="text-align: center;">${symTotalShares.toFixed(0)}</td>`;
                }

                // Check for price changes and apply flash animations
                const priceCellId = `price-${sym}`;
                const oldPriceData = oldPricesLookup; // use either raw or normalized key
                let priceFlashClass = '';

                if (oldPriceData && newPriceData) {
                    const oldPrice = oldPriceData.price;
                    const newPrice = newPriceData.price;
                    if (oldPrice !== 0 && newPrice !== oldPrice) {
                        priceFlashClass = newPrice > oldPrice ? 'flash-positive' : 'flash-negative';
                    }
                }

                // Parse changePct to number for sorting
                let changePctNum = 0;
                if (changePct && changePct !== '0%') {
                    changePctNum = parseFloat(changePct.replace('%', '').replace(',', '')) || 0;
                }
                rowInfo.changePct = changePctNum;
                rowInfo.valueChange = symTotalValueChange;
                rowInfo.total = symTotalValue;

                // Build a tooltip showing prev-close source & time (if available)
                let prevCloseTooltip = '';
                if (prevClose && prevClose !== 0) {
                    const prevCloseSource = (newPriceData && (newPriceData.prev_close_source || newPriceData.previous_close_source)) || (oldPrices[sym] && (oldPrices[sym].prev_close_source || oldPrices[sym].previous_close_source)) || '';
                    const prevCloseTime = (newPriceData && (newPriceData.prev_close_time || newPriceData.previous_close_time || newPriceData.capture_time)) || (oldPrices[sym] && (oldPrices[sym].prev_close_time || oldPrices[sym].previous_close_time || oldPrices[sym].capture_time)) || '';
                    if (prevCloseSource) prevCloseTooltip += `Source: ${prevCloseSource}`;
                    if (prevCloseTime) prevCloseTooltip += (prevCloseTooltip ? '\n' : '') + `Time: ${prevCloseTime}`;
                }
                rowHtml += `<td id="prevClose-${sym}" ${prevCloseTooltip ? `title="${escapeHtml(prevCloseTooltip)}"` : ''}>${formatNumber(prevClose)}${prevCloseTooltip ? ` <span class="prev-close-info" title="${escapeHtml(prevCloseTooltip)}">ℹ</span>` : ''}</td>`;
                rowHtml += `<td id="${priceCellId}" class="${priceFlashClass}">${formatNumber(price)}</td>`;
                rowHtml += `<td>${metaPE}</td>`;
                rowHtml += `<td>${metaYield}</td>`;

                // Check for change and change% column changes
                const changeCellId = `change-${sym}`;
                const changePctCellId = `changePct-${sym}`;
                let changeFlashClass = '';
                let changePctFlashClass = '';

                if (oldPriceData && newPriceData) {
                    const oldChange = oldPriceData.change || 0;
                    const newChange = changeVal;
                    if (oldChange !== 0 && newChange !== oldChange) {
                        changeFlashClass = newChange > oldChange ? 'flash-positive' : 'flash-negative';
                    }

                    const oldChangePct = oldPriceData.change_percent || '0%';
                    const newChangePct = changePct;
                    if (oldChangePct !== '0%' && newChangePct !== oldChangePct) {
                        const oldChangePctNum = parseFloat(oldChangePct.replace('%', '').replace(',', '')) || 0;
                        const newChangePctNum = changePctNum;
                        if (oldChangePctNum !== 0 && newChangePctNum !== oldChangePctNum) {
                            changePctFlashClass = newChangePctNum > oldChangePctNum ? 'flash-positive' : 'flash-negative';
                        }
                    }
                }

                rowHtml += `<td id="${changeCellId}" class="${changeFlashClass}" style="color: ${color}">${formatNumber(changeVal)}</td>`;
                rowHtml += `<td id="${changePctCellId}" class="${changePctFlashClass}" style="color: ${color}">${changePctNum.toFixed(3)}%</td>`;

                // Check for time and source changes (text flash)
                const timeCellId = `time-${sym}`;
                const sourceCellId = `source-${sym}`;
                let timeFlashClass = '';
                let sourceFlashClass = '';

                if (oldPriceData && newPriceData) {
                    const oldTime = oldPriceData.time || '-';
                    const newTime = timeStr;
                    const oldSource = oldPriceData.source || '-';
                    const newSource = sourceStr;

                    if (oldTime !== newTime) {
                        timeFlashClass = 'flash-text';
                    }
                    if (oldSource !== newSource) {
                        sourceFlashClass = 'flash-text';
                    }
                }

                rowHtml += `<td id="${timeCellId}" class="${timeFlashClass}" style="font-size: 0.50em; color: #888;">${timeStr}</td>`;
                rowHtml += `<td id="${sourceCellId}" class="${sourceFlashClass}" style="font-size: 0.50em; color: #888;">${sourceStr}</td>`;

                grandTotalValueChange += symTotalValueChange;

                // Check for value change and total changes
                const valueChangeCellId = `valueChange-${sym}`;
                const totalCellId = `total-${sym}`;
                let valueChangeFlashClass = '';
                let totalFlashClass = '';

                if (oldPriceData && newPriceData) {
                    const oldValueChange = previousValues[valueChangeCellId] || 0;
                    const newValueChange = symTotalValueChange;
                    if (oldValueChange !== 0 && newValueChange !== oldValueChange) {
                        valueChangeFlashClass = newValueChange > oldValueChange ? 'flash-positive' : 'flash-negative';
                    }
                    previousValues[valueChangeCellId] = newValueChange;

                    const oldTotal = previousValues[totalCellId] || 0;
                    const newTotal = symTotalValue;
                    if (oldTotal !== 0 && newTotal !== oldTotal) {
                        totalFlashClass = newTotal > oldTotal ? 'flash-positive' : 'flash-negative';
                    }
                    previousValues[totalCellId] = newTotal;
                }

                rowHtml += `<td id="${valueChangeCellId}" class="${valueChangeFlashClass}" style="color: ${color}">${formatNumber(symTotalValueChange)}</td>`;
                rowHtml += `<td id="${totalCellId}" class="${totalFlashClass} row-total">${formatNumber(symTotalValue, 0)}</td></tr>`;

                rowInfo.html = rowHtml;
                rowData.push(rowInfo);
            });

            // Sort rows based on current sort state
            rowData.sort((a, b) => {
                let aVal = a[investmentGridSort.column];
                let bVal = b[investmentGridSort.column];
                if (investmentGridSort.column === 'symbol' || investmentGridSort.column === 'name' || investmentGridSort.column === 'sector') {
                    aVal = (aVal || '').toLowerCase();
                    bVal = (bVal || '').toLowerCase();
                }
                if (aVal < bVal) return investmentGridSort.direction === 'asc' ? -1 : 1;
                if (aVal > bVal) return investmentGridSort.direction === 'asc' ? 1 : -1;
                return 0;
            });

            // Build body HTML from sorted rows
            rowData.forEach(row => {
                bodyHtml += row.html;
            });

            // Cash Row
            let cashRowHtml = '<tr><td style="text-align: left; font-weight: bold;">CASH</td>';
            let totalCash = 0;
            accounts.forEach(acc => {
                let cashVal = 0;
                let cashPos = acc.holdings.cash;
                if (cashPos) {
                    cashVal = cashPos.value;
                    if (!accountsCollapsed) {
                        const posData = { id: cashPos.id, account_id: acc.id, symbol: 'CASH', type: 'cash', quantity: cashVal };
                        const posJson = escapeHtml(JSON.stringify(posData));
                        cashRowHtml += `<td><span class="clickable-cell" onclick="openPositionModal(${posJson})">${formatNumber(cashVal)}</span></td>`;
                    }
                } else {
                    if (!accountsCollapsed) {
                        const posData = { account_id: acc.id, symbol: 'CASH', type: 'cash', quantity: 0 };
                        const posJson = escapeHtml(JSON.stringify(posData));
                        cashRowHtml += `<td><span class="clickable-cell" style="color: #555; text-align: center;" onclick="openPositionModal(${posJson})">+</span></td>`;
                    }
                }
                totalCash += cashVal;
            });
            // If collapsed, add single cell for Shares column (show dash for cash)
            if (accountsCollapsed) {
                cashRowHtml += '<td style="text-align: center;">-</td>';
            }
            cashRowHtml += '<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td>';
            cashRowHtml += `<td class="row-total">${formatNumber(totalCash, 0)}</td></tr>`;
            bodyHtml += cashRowHtml;

            // Account Totals
            let totalRowHtml = '<tr class="total-row"><td>TOTAL</td>';
            let grandTotal = 0;
            accounts.forEach(acc => {
                let accTotal = 0;
                if (acc.holdings.cash) accTotal += acc.holdings.cash.value;
                acc.holdings.stocks.forEach(p => {
                    const price = getPriceDataForSymbol(p.symbol)?.price || 0;
                    accTotal += p.quantity * price;
                });
                acc.holdings.bonds.forEach(p => {
                    const price = getPriceDataForSymbol(p.symbol)?.price || 0;
                    accTotal += p.quantity * (price / 100.0);
                });
                grandTotal += accTotal;
                if (!accountsCollapsed) {
                    totalRowHtml += `<td id="total-row-acc-${acc.id}">${formatNumber(accTotal)}</td>`;
                }
            });
            // If collapsed, add single cell for Shares column (show dash for totals)
            if (accountsCollapsed) {
                totalRowHtml += '<td style="text-align: center;">-</td>';
            }
            let totalChangeColor = '#e0e0e0';
            if (grandTotalValueChange > 0) totalChangeColor = '#4caf50';
            if (grandTotalValueChange < 0) totalChangeColor = '#f44336';

            totalRowHtml += '<td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td>';
            totalRowHtml += `<td id="total-row-value-change" style="color: ${totalChangeColor}">${formatNumber(grandTotalValueChange)}</td>`;
            totalRowHtml += `<td id="total-row-grand-total">${formatNumber(grandTotal, 0)}</td></tr>`;
            bodyHtml += totalRowHtml;

            // Removed Add Position Buttons row

            tbody.innerHTML = bodyHtml;
        }

        function sortInvestmentGrid(column) {
            if (investmentGridSort.column === column) {
                // Toggle direction
                investmentGridSort.direction = investmentGridSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                // New column, default to ascending for symbol, descending for numbers
                investmentGridSort.column = column;
                investmentGridSort.direction = column === 'symbol' ? 'asc' : 'desc';
            }
            renderAll();
        }

        function renderBankGrid(tableId, accounts) {
            const gridTable = document.getElementById(tableId);
            const thead = gridTable.querySelector('thead');
            const tbody = gridTable.querySelector('tbody');

            if (!accounts || accounts.length === 0) {
                thead.innerHTML = '';
                tbody.innerHTML = '<tr><td>No bank accounts found.</td></tr>';
                return;
            }

            thead.innerHTML = `<tr>
                <th style="text-align: left">Account Name</th>
                <th style="text-align: left">Type</th>
                <th>Value</th>
            </tr>`;

            let bodyHtml = '';
            let total = 0;

            accounts.forEach(acc => {
                let val = 0;
                let cashPos = acc.holdings.cash;
                if (cashPos) val = cashPos.value;
                total += val;

                const accJson = escapeHtml(JSON.stringify(acc));

                let valCell = '';
                if (cashPos) {
                    const posData = { id: cashPos.id, account_id: acc.id, symbol: 'CASH', type: 'cash', quantity: val, isBankAccount: true };
                    const posJson = escapeHtml(JSON.stringify(posData));
                    valCell = `<span class="clickable-cell" onclick="openPositionModal(${posJson})">${formatNumber(val)} <span class="edit-icon">✎</span></span>`;
                } else {
                    const posData = { account_id: acc.id, symbol: 'CASH', type: 'cash', quantity: 0, isBankAccount: true };
                    const posJson = escapeHtml(JSON.stringify(posData));
                    valCell = `<span class="clickable-cell" onclick="openPositionModal(${posJson})">${formatNumber(0)} <span class="edit-icon">✎</span></span>`;
                }

                bodyHtml += `<tr>
                    <td><span class="clickable-cell" onclick="openAccountModal('bank', ${accJson})">${acc.name} <span class="edit-icon">✎</span></span></td>
                    <td style="text-align: left">${acc.type}</td>
                    <td>${valCell}</td>
                </tr>`;
            });

            bodyHtml += `<tr class="total-row"><td colspan="2">TOTAL</td><td>${formatNumber(total)}</td></tr>`;
            tbody.innerHTML = bodyHtml;
        }

        function renderAssetGrid(tableId, assets) {
            const gridTable = document.getElementById(tableId);
            const thead = gridTable.querySelector('thead');
            const tbody = gridTable.querySelector('tbody');

            if (!assets || assets.length === 0) {
                thead.innerHTML = '';
                tbody.innerHTML = '<tr><td>No fixed assets found.</td></tr>';
                return;
            }

            thead.innerHTML = `<tr>
                <th style="text-align: left">Name</th>
                <th style="text-align: left">Type</th>
                <th>Value</th>
            </tr>`;

            let bodyHtml = '';
            let total = 0;

            assets.forEach(asset => {
                total += asset.value;
                const assetJson = escapeHtml(JSON.stringify(asset));
                bodyHtml += `<tr>
                    <td><span class="clickable-cell" onclick="openAssetModal(${assetJson})">${asset.description || asset.name} <span class="edit-icon">✎</span></span></td>
                    <td style="text-align: left">${asset.type}</td>
                    <td><span class="clickable-cell" onclick="openAssetModal(${assetJson})">${formatNumber(asset.value)} <span class="edit-icon">✎</span></span></td>
                </tr>`;
            });

            bodyHtml += `<tr class="total-row"><td colspan="2">TOTAL</td><td>${formatNumber(total)}</td></tr>`;
            tbody.innerHTML = bodyHtml;
        }

        // --- Drag and Drop for Columns ---
        function dragStart(ev, id) {
            ev.dataTransfer.setData("text/plain", id);
            ev.dataTransfer.effectAllowed = "move";
        }

        function allowDrop(ev) {
            ev.preventDefault();
        }

        function drop(ev, targetId) {
            ev.preventDefault();
            const draggedId = ev.dataTransfer.getData("text/plain");
            if (String(draggedId) === String(targetId)) return;

            const fromIndex = accountOrder.findIndex(id => String(id) === String(draggedId));
            const toIndex = accountOrder.findIndex(id => String(id) === String(targetId));

            if (fromIndex > -1 && toIndex > -1) {
                const [movedItem] = accountOrder.splice(fromIndex, 1);
                accountOrder.splice(toIndex, 0, movedItem);
                renderAll();
                saveAccountOrder();
            }
        }

        async function saveAccountOrder() {
            // Update display_order for all accounts in the new order
            const updates = accountOrder.map((id, index) => {
                return fetch(`/api/accounts/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ display_order: index })
                });
            });

            try {
                await Promise.all(updates);
                console.log('Account order saved');
            } catch (err) {
                console.error('Error saving account order:', err);
            }
        }

        // --- Helpers ---
        // Normalize ticker strings to the same key format used by scrapers/price messages
        // (underscore-sanitized form for filename compatibility)
        function normalizeTicker(sym) {
            if (!sym && sym !== 0) return sym;
            try {
                return String(sym).toUpperCase().replace(/[^A-Z0-9._-]/g, '_');
            } catch (e) {
                return String(sym).toUpperCase();
            }
        }

        // Percent-encode ticker to match server-side normalized_key format
        // (e.g., GC=F -> GC%3DF)
        function percentEncodeTicker(sym) {
            if (!sym && sym !== 0) return sym;
            try {
                return encodeURIComponent(String(sym).toUpperCase());
            } catch (e) {
                return String(sym).toUpperCase();
            }
        }

        // Safe accessor for currentPrices that falls back to normalized/encoded keys
        // Server's priceCache uses percent-encoded keys (normalized_key), so we try:
        // 1. Direct symbol lookup (e.g., "AAPL")
        // 2. Percent-encoded form (e.g., "GC=F" -> "GC%3DF")
        // 3. Underscore-sanitized form (e.g., "GC=F" -> "GC_F") for legacy compatibility
        function getPriceDataForSymbol(sym) {
            if (!sym && sym !== 0) return undefined;
            // direct lookup
            let data = currentPrices[sym];
            if (data) return data;
            // try percent-encoded form (server's normalized_key)
            const encoded = percentEncodeTicker(sym);
            if (encoded !== sym) {
                data = currentPrices[encoded];
                if (data) return data;
            }
            // try underscore-sanitized form (legacy/filename compatibility)
            const norm = normalizeTicker(sym);
            if (norm !== sym && norm !== encoded) data = currentPrices[norm];
            return data;
        }
        function formatNumber(num, decimals = 2) {
            return new Intl.NumberFormat('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(num);
        }

        function escapeHtml(str) {
            return str.replace(/"/g, '&quot;');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        window.onclick = function (event) {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = "none";
            }
        }

        // Add Escape key support to close modals
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                // Close any open modal
                const modals = document.getElementsByClassName('modal');
                for (let i = 0; i < modals.length; i++) {
                    if (modals[i].style.display === 'block') {
                        modals[i].style.display = 'none';
                        break; // Close only the first open modal
                    }
                }
            }
        });

        // --- Modal Logic ---

        // Account
        function openAccountModal(category, account = null) {
            const modal = document.getElementById('accountModal');
            const form = document.getElementById('accountForm');
            form.reset();
            document.getElementById('accId').value = '';
            document.getElementById('accCategory').value = category || '';
            document.getElementById('btnDeleteAccount').style.display = 'none';
            document.getElementById('accountModalTitle').innerText = 'Add Account';

            if (account) {
                document.getElementById('accountModalTitle').innerText = 'Edit Account';
                document.getElementById('accId').value = account.id;
                document.getElementById('accName').value = account.name;
                document.getElementById('accType').value = account.type;
                document.getElementById('accCategory').value = account.category;
                document.getElementById('btnDeleteAccount').style.display = 'block';
            }
            modal.style.display = 'block';
        }

        document.getElementById('accountForm').onsubmit = async function (e) {
            e.preventDefault();
            const id = document.getElementById('accId').value;
            const body = {
                name: document.getElementById('accName').value,
                type: document.getElementById('accType').value,
                category: document.getElementById('accCategory').value
            };
            const method = id ? 'PUT' : 'POST';
            const url = id ? `/api/accounts/${id}` : '/api/accounts';

            await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            closeModal('accountModal');
            fetchAssets();
        };

        async function deleteAccount() {
            const id = document.getElementById('accId').value;
            showConfirmModal(
                'Delete Account',
                'All positions in this account will also be deleted. Are you sure?',
                async () => {
                    await fetch(`/api/accounts/${id}`, { method: 'DELETE' });
                    closeModal('accountModal');
                    fetchAssets();
                }
            );
        }

        function showConfirmModal(title, message, onConfirm) {
            document.getElementById('confirmModalTitle').innerText = title;
            document.getElementById('confirmModalMessage').innerText = message;
            const okBtn = document.getElementById('confirmModalOk');
            // Hide any open modal (asset/account/position) before showing confirm
            const modalsToHide = ['accountModal', 'positionModal', 'assetModal'];
            let lastOpenModal = null;
            for (const mid of modalsToHide) {
                const m = document.getElementById(mid);
                if (m && m.style.display === 'block') {
                    m.style.display = 'none';
                    lastOpenModal = mid;
                }
            }
            okBtn.onclick = () => {
                closeModal('confirmModal');
                onConfirm();
            };
            // Restore the previous modal if cancel is clicked
            const cancelBtn = document.querySelector('#confirmModal .btn:not(.btn-danger)');
            cancelBtn.onclick = () => {
                closeModal('confirmModal');
                if (lastOpenModal) document.getElementById(lastOpenModal).style.display = 'block';
            };
            document.getElementById('confirmModal').style.display = 'block';
        }

        // Position
        function openPositionModal(pos) {
            const modal = document.getElementById('positionModal');
            const form = document.getElementById('positionForm');
            form.reset();
            document.getElementById('posId').value = '';
            document.getElementById('btnDeletePosition').style.display = 'none';
            document.getElementById('positionModalTitle').innerText = 'Add Position';

            document.getElementById('posAccountId').value = pos.account_id;
            document.getElementById('posQuantity').value = pos.quantity;
            document.getElementById('posSymbol').value = pos.symbol;
            document.getElementById('posType').value = pos.type;

            // Output-only fields
            document.getElementById('posSymbolDisplay').textContent = pos.symbol;
            document.getElementById('posTypeDisplay').textContent = (pos.type || '').charAt(0).toUpperCase() + (pos.type || '').slice(1);
            // Use account_name if present, otherwise look up
            let accountName = pos.account_name || '';
            if (!accountName && window.lastAssetsData && window.lastAssetsData.accounts) {
                const acc = window.lastAssetsData.accounts.find(a => String(a.id) === String(pos.account_id));
                if (acc) accountName = acc.name;
            }
            document.getElementById('posAccountDisplay').textContent = accountName;

            // Hide Symbol/Type fields for cash
            const isCash = pos.type === 'cash';
            const isBankCash = isCash && pos.isBankAccount;
            document.getElementById('posSymbolGroup').style.display = isCash ? 'none' : 'block';
            document.getElementById('posTypeGroup').style.display = isBankCash ? 'none' : 'block';
            document.getElementById('btnDeletePosition').style.display = isBankCash ? 'none' : (pos.id ? 'block' : 'none');

            if (pos.id) {
                document.getElementById('positionModalTitle').innerText = 'Edit Position';
                document.getElementById('posId').value = pos.id;
            }
            modal.style.display = 'block';
        }

        document.getElementById('positionForm').onsubmit = async function (e) {
            e.preventDefault();
            const id = document.getElementById('posId').value;
            const body = {
                account_id: document.getElementById('posAccountId').value,
                symbol: document.getElementById('posSymbol').value,
                type: document.getElementById('posType').value,
                quantity: parseFloat(document.getElementById('posQuantity').value),
                currency: 'USD'
            };
            const method = id ? 'PUT' : 'POST';
            const url = id ? `/api/positions/${id}` : '/api/positions';

            await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            closeModal('positionModal');
            fetchAssets();
        };

        async function deletePosition() {
            const id = document.getElementById('posId').value;
            if (!confirm('Delete this position?')) return;
            await fetch(`/api/positions/${id}`, { method: 'DELETE' });
            closeModal('positionModal');
            fetchAssets();
        }

        // Asset
        function openAssetModal(asset = null) {
            const modal = document.getElementById('assetModal');
            const form = document.getElementById('assetForm');
            form.reset();
            document.getElementById('assetId').value = '';
            document.getElementById('btnDeleteAsset').style.display = 'none';
            document.getElementById('assetModalTitle').innerText = 'Add Asset';

            if (asset) {
                document.getElementById('assetModalTitle').innerText = 'Edit Asset';
                document.getElementById('assetId').value = asset.id;
                document.getElementById('assetName').value = asset.description || asset.name;
                document.getElementById('assetType').value = asset.type;
                document.getElementById('assetValue').value = asset.value;
                document.getElementById('btnDeleteAsset').style.display = 'block';
            }
            modal.style.display = 'block';
        }

        document.getElementById('assetForm').onsubmit = async function (e) {
            e.preventDefault();
            const id = document.getElementById('assetId').value;
            const body = {
                name: document.getElementById('assetName').value,
                type: document.getElementById('assetType').value,
                value: parseFloat(document.getElementById('assetValue').value),
                currency: 'USD',
                display_order: 0
            };
            const method = id ? 'PUT' : 'POST';
            const url = id ? `/api/fixed_assets/${id}` : '/api/fixed_assets';

            await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            closeModal('assetModal');
            fetchAssets();
        };

        async function deleteAsset() {
            const id = document.getElementById('assetId').value;
            showConfirmModal(
                'Delete Asset',
                'Are you sure you want to delete this asset?',
                async () => {
                    await fetch(`/api/fixed_assets/${id}`, { method: 'DELETE' });
                    closeModal('assetModal');
                    fetchAssets();
                }
            );
        }

        // --- Tabs & Logs ---
        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

            if (tabName === 'Logs') {
                fetchLogs();
            }
        }

        async function fetchLogs() {
            try {
                const response = await fetch('/api/logs');
                const files = await response.json();
                const tbody = document.getElementById('log-list');
                tbody.innerHTML = '';
                files.forEach(file => {
                    const tr = document.createElement('tr');
                    tr.style.cursor = 'pointer';
                    tr.onclick = () => viewLog(file.name);
                    tr.onmouseover = () => tr.style.backgroundColor = '#333';
                    tr.onmouseout = () => tr.style.backgroundColor = 'transparent';

                    const date = new Date(file.timestamp).toLocaleString();
                    const size = (file.size / 1024).toFixed(1) + ' KB';

                    tr.innerHTML = `
                        <td style="padding: 5px; border-bottom: 1px solid #333; word-break: break-all;">${file.name}</td>
                        <td style="padding: 5px; border-bottom: 1px solid #333;">${date}</td>
                        <td style="padding: 5px; border-bottom: 1px solid #333; text-align: right;">${size}</td>
                    `;
                    tbody.appendChild(tr);
                });
            } catch (error) {
                console.error('Error fetching logs:', error);
            }
        }

        async function viewLog(filename) {
            try {
                const viewer = document.getElementById('log-viewer-pane');
                if (filename.toLowerCase().endsWith('.png')) {
                    // Display image
                    viewer.innerHTML = `<img src="/api/logs/${encodeURIComponent(filename)}" alt="${filename}" style="max-width:100%; max-height:80vh; display:block; margin:auto; background:#222; border-radius:8px;" />`;
                } else {
                    const response = await fetch(`/api/logs/${filename}`);
                    if (filename.endsWith('.json')) {
                        const data = await response.json();
                        viewer.innerText = JSON.stringify(data, null, 2);
                    } else {
                        const text = await response.text();
                        viewer.innerText = text;
                    }
                }
            } catch (error) {
                document.getElementById('log-viewer-pane').innerText = 'Error loading file: ' + error;
            }
        }

        // --- Resizing Logic ---

        // 1. Split Pane Resizer
        const paneResizer = document.getElementById('pane-resizer');
        const leftPane = document.getElementById('log-list-pane');
        const rightPane = document.getElementById('log-viewer-pane');
        const logsContainer = document.getElementById('logs-container');

        if (paneResizer) {
            let x = 0;
            let leftWidth = 0;

            const onMouseDownPane = function (e) {
                x = e.clientX;
                leftWidth = leftPane.getBoundingClientRect().width;

                document.addEventListener('mousemove', onMouseMovePane);
                document.addEventListener('mouseup', onMouseUpPane);

                // Visual feedback
                paneResizer.style.backgroundColor = '#666';
            };

            const onMouseMovePane = function (e) {
                const dx = e.clientX - x;
                const containerWidth = logsContainer.getBoundingClientRect().width;
                const newLeftWidth = ((leftWidth + dx) / containerWidth) * 100;

                // Limits (10% to 90%)
                if (newLeftWidth > 10 && newLeftWidth < 90) {
                    leftPane.style.width = `${newLeftWidth}%`;
                }

                document.body.style.cursor = 'col-resize';
                leftPane.style.userSelect = 'none';
                leftPane.style.pointerEvents = 'none';
                rightPane.style.userSelect = 'none';
                rightPane.style.pointerEvents = 'none';
            };

            const onMouseUpPane = function () {
                document.removeEventListener('mousemove', onMouseMovePane);
                document.removeEventListener('mouseup', onMouseUpPane);

                document.body.style.cursor = 'default';
                leftPane.style.removeProperty('user-select');
                leftPane.style.removeProperty('pointer-events');
                rightPane.style.removeProperty('user-select');
                rightPane.style.removeProperty('pointer-events');
                paneResizer.style.backgroundColor = '#444';
            };

            paneResizer.addEventListener('mousedown', onMouseDownPane);
        }

        // 2. Table Column Resizer
        function createResizableColumn(col, resizer) {
            let x = 0;
            let w = 0;

            const onMouseDownCol = function (e) {
                e.stopPropagation(); // Prevent bubbling
                x = e.clientX;
                w = col.getBoundingClientRect().width;

                document.addEventListener('mousemove', onMouseMoveCol);
                document.addEventListener('mouseup', onMouseUpCol);
                resizer.style.backgroundColor = '#888';
            };

            const onMouseMoveCol = function (e) {
                const dx = e.clientX - x;
                // Set width in pixels to override percentage
                col.style.width = `${w + dx}px`;
            };

            const onMouseUpCol = function () {
                document.removeEventListener('mousemove', onMouseMoveCol);
                document.removeEventListener('mouseup', onMouseUpCol);
                resizer.style.backgroundColor = '#555';
            };

            resizer.addEventListener('mousedown', onMouseDownCol);
        }

        // Initialize column resizers
        ['col-file'].forEach(id => {
            const th = document.getElementById(id);
            if (th) {
                const resizer = document.createElement('div');
                resizer.style.width = '5px';
                resizer.style.height = '100%';
                resizer.style.position = 'absolute';
                resizer.style.top = '0';
                resizer.style.right = '0';
                resizer.style.cursor = 'col-resize';
                resizer.style.backgroundColor = '#555'; // Visible handle
                resizer.style.userSelect = 'none';
                resizer.style.zIndex = '5';

                th.appendChild(resizer);
                createResizableColumn(th, resizer);
            }
        });

        // --- Settings Dropdown ---
        function toggleSettingsDropdown() {
            const dropdown = document.getElementById('settingsDropdown');
            const isVisible = dropdown.style.display === 'block';

            // Hide dropdown if visible
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                // Show dropdown
                dropdown.style.display = 'block';
            }
        }

        function showLogs() {
            const dropdown = document.getElementById('settingsDropdown');
            dropdown.style.display = 'none';

            // Open logs modal
            document.getElementById('logsModal').style.display = 'block';

            // Fetch logs if not already loaded
            fetchLogs();
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const dropdown = document.getElementById('settingsDropdown');
            const settingsBtn = document.getElementById('settingsBtn');

            if (!settingsBtn.contains(event.target) && !dropdown.contains(event.target)) {
                dropdown.style.display = 'none';
            }
        });

        // --- Settings ---
        function openSettingsModal() {
            const dropdown = document.getElementById('settingsDropdown');
            dropdown.style.display = 'none'; // Close dropdown when opening modal

            const modal = document.getElementById('settingsModal');
            // Load current settings (from localStorage or defaults)
            loadSettings();
            modal.style.display = 'block';
        }

        function loadSettings() {
            // Load settings from localStorage or set defaults
            const autoRefresh = localStorage.getItem('autoRefresh') !== 'false'; // default true
            const refreshInterval = localStorage.getItem('refreshInterval') || '60';
            const theme = localStorage.getItem('theme') || 'dark';

            document.getElementById('autoRefresh').checked = autoRefresh;
            document.getElementById('refreshInterval').value = refreshInterval;
            document.getElementById('theme').value = theme;
        }

        function saveSettings() {
            // Save settings to localStorage
            const autoRefresh = document.getElementById('autoRefresh').checked;
            const refreshInterval = document.getElementById('refreshInterval').value;
            const theme = document.getElementById('theme').value;

            localStorage.setItem('autoRefresh', autoRefresh);
            localStorage.setItem('refreshInterval', refreshInterval);
            localStorage.setItem('theme', theme);

            // Apply settings immediately
            applySettings();

            closeModal('settingsModal');

            // Show success message
            alert('Settings saved successfully!');
        }

        function applySettings() {
            const theme = localStorage.getItem('theme') || 'dark';
            const autoRefresh = localStorage.getItem('autoRefresh') !== 'false';
            const refreshInterval = parseInt(localStorage.getItem('refreshInterval') || '60');

            // Apply theme (basic implementation - could be expanded)
            if (theme === 'light') {
                document.body.style.backgroundColor = '#ffffff';
                document.body.style.color = '#000000';
            } else {
                document.body.style.backgroundColor = '#121212';
                document.body.style.color = '#e0e0e0';
            }

            // Apply auto-refresh
            if (autoRefresh && window.refreshIntervalId) {
                clearInterval(window.refreshIntervalId);
            }
            if (autoRefresh) {
                window.refreshIntervalId = setInterval(fetchAssets, refreshInterval * 1000);
            }
        }

        function exportData() {
            // Basic data export functionality
            if (confirm('Export all account and position data?')) {
                fetch('/api/export')
                    .then(response => response.json())
                    .then(data => {
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `wealth-tracker-export-${new Date().toISOString().split('T')[0]}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    })
                    .catch(err => alert('Export failed: ' + err.message));
            }
        }

        function importData(fileInput) {
            const file = fileInput.files[0];
            if (!file) return;

            if (!confirm('Import data from file? This will REPLACE all existing account and position data. Continue?')) {
                // Reset file input
                fileInput.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const importData = JSON.parse(e.target.result);

                    // Validate the data structure
                    if (!importData.data || !importData.data.accounts || !importData.data.positions) {
                        throw new Error('Invalid file format. Expected exported wealth-tracker data.');
                    }

                    // Send to server for import
                    fetch('/api/import', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(importData)
                    })
                        .then(response => response.json())
                        .then(result => {
                            if (result.success) {
                                alert('Data imported successfully!');
                                // Refresh the dashboard data
                                fetchAssets();
                                closeModal('settingsModal');
                            } else {
                                alert('Import failed: ' + (result.error || 'Unknown error'));
                            }
                        })
                        .catch(err => {
                            alert('Import failed: ' + err.message);
                        });
                } catch (err) {
                    alert('Failed to parse file: ' + err.message);
                }
            };

            reader.readAsText(file);
            // Reset file input
            fileInput.value = '';
        }

        function clearCache() {
            if (confirm('Clear all cached data? This will force a fresh reload of all data.')) {
                localStorage.clear();
                sessionStorage.clear();
                // Clear any cached ticker data
                tickerList = [];
                tickerData = [];
                tickerLookup = {};
                // Reload the page to apply changes
                location.reload();
            }
        }

        // Apply settings on page load
        document.addEventListener('DOMContentLoaded', function () {
            applySettings();
            fetchAssets();
        });

    </script>
</body>

</html>